# 汇编语言

## 序章 前言

### 1.1 教学思想

​	一门课程是由相互关联的知识构成的，这些知识在一本书中如何组织则是一种信息组织和加工的艺术。学习是一个循序渐进的过程，但并不是所有的教学都是以这种方式完成的，这并不是我们所希望看到的事情，因为任何不以循序渐进的方式进行的学习，都将出现盲目探索和不成系统的情况，最终学习到的也大都是相对零散的知识，并不能建立起一个系统的知识结构。非循序渐进的学习，也达不到循序渐进学习所能达到的深度，因为后者是步步深入的，每一步都以前一步为基础。

​	为学习者构造合理的学习线索，这个学习线索应真正地遵循**循序渐进**的原则。我们需要打破传统的章节划分，以一种新的艺术来对课程的内容进行补充、分割、重组，使其成为一个个串联在学习线索上的完成特定教学功能的教学节点。本书以此作为创作的核心理念，打破了传统的章节划分，构造了合理的学习线索，将课程的内容拆解到学习线索中的各个教学节点中去。学习主线索上的教学节点有4类：①知识点（即各小节内容）；②检测点；③问题和分析；④实验。还有一种被称为附注的教学节点不在学习主线索之中，是由知识点引出的节点，属于选看内容。

​	为了按循序渐进的原则构造学习线索，本书采用了一种全新的信息组织和加工艺术，我们称其为**知识屏蔽**。有的教材只注重知识的授予，并不注重知识的屏蔽。在教学中知识的屏蔽十分重要，这是一个重点突出的问题。计算机是一门交叉学科，一部分知识往往还连带着其他的相关内容，这些连带的相关内容如果处理不好，将影响学习者对目前要掌握的知识的理解。本书采用了知识屏蔽的方法，对教学内容进行了最小化分割，力求使我们在学习过程中所接触到的每一个知识点都是当前唯一要去理解的东西。我们在看到这个知识点之前，已理解了以前所有的内容；在学习这个知识点的过程中，以后的知识也不会对我们造成干扰。我们在整个学习过程中，每一步都走得清楚而扎实，不知不觉中，由当初的一个简单的问题开始，在经历了一个每一步都相对简单的过程之后，被带入了一个深的层次。这同沿着楼梯上高楼一样，迈出的每一步都不高，结果却上了楼顶。

### 1.2 本书的结构

本书由若干章构成，一章包含若干知识点，根据具体内容，还可能包含检测点、问题和分析、实验、附注等教学节点。书中的所有教学节点，除附注之外，都在一个全程的主线索之中。

由于本书具有很强的线索性，学习一定要按照教学的线索进行，有两点是必须要遵守的原则：①没有通过检测点不要向下学习；②没有完成当前的实验不要向下学习。

下面的表格详细说明了书中的各种教学节点和它们的组织情况。

<center style="color:#C0C0C0">表 教学节点详表</center>

| 教学节点 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 知识点   | 学习者的主要知识来源。知识点以小节的形式出现，一个知识点为一个小节。每一个知识点都有一个相对独立的小主题。 |
| 附注     | 有些内容是对主要内容的拓展、加深和补充。这些内容如果放入正文中，会分散学习者对主体内容的注意力，同时也破坏了主体内容的系统性。我们把这些内容在附注中给出，供学习者选看。附注不在主线索之中，是主线索的引出内容。 |
| 检测点   | 检测点用来取得学习情况的反馈。只要通过了检测点，我们就得到了一个保证：已掌握了前面的内容。这是对学习成果的阶段性的肯定，有了这个肯定，可以信心十足地继续学习。如果没有通过检测点，需要回头再进行复习。有的检测点中也包含了一些具有教学功能的内容。 |
| 问题分析 | 引导学习者对知识进行深入的理解和灵活的应用。                 |
| 实验     | 在本书中，实验也是在学习线索中的。有的教学内容就包含在编程的依据材料中。每一实验个实验都是后续内容的基础，实验的任务必须独立完成。我们可以这样看待实验的重要性，如果你没有完成当前的实验，就应停止继续学习，直到你独立完成实验。 |

### 1.3 教学重心和内容特点

本书的教学重心是：通过**学习关键指令来深入理解机器工作的基本原理，培养底层编程意识和思想**。本着这个原则，本书的内容将和传统的教材有着很大的不同。

​	(1)不讲解每一条指令的功能

​	指令仅仅是学习机器基本原理和设计思想的一种实例。而逐条地讲解每一条指令的功能，不是本书的职责所在，它应该是一本指令手册的核心内容。这就好像文学作品和字典的区别，前者的重心在于用文字表达思想，后者讲解每个字的用法。

​	(2)编程的平台是硬件而不是操作系统

​	这一点尤为重要，直接影响以后的操作系统的教学。我们必须通过一定的编程实践，体验一个裸机的环境，在一个没有操作系统的环境中直接对硬件编程。这样的体会和经验非常重要，这样我们才能真正体会到汇编语言的作用，并且看到没有操作系统的计算机系统是怎样的。这为以后的操作系统的学习打下了一个重要的基础。

​	(3)着重讲解重要指令和关键概念

​	本书的所有内容都是围绕着“深入理解机器工作的基本原理”和“培养底层编程意识和思想”这两个核心目标来进行的。对所有和这两个目标关系并不密切的内容，都进行了舍弃。使学习者可以集中注意力真正理解和掌握那些具有普遍意义的指令和关键概念。

​	本书在深入到本质的层面上对重要指令和关键概念进行了讲解和讨论。这些指令和概念有：jmp、条件转移指令、call、ret、栈指令、int、iret、cmp、loop、分段、寻址方式等。 

### 1.4 读者定位

​	本书可用作大学计算机专业本科的汇编教材，和希望深入学习计算机科学的学习者的自学教材。本书的读者应具备以下基础：

​	①具有计算机的使用经验；

​	②具有二进制、十六进制等基础知识；

​	③具有一门高级语言（BASIC、Pascal、C...）的基本编程基础。

### 1.5 联系方法

​	《汇编语言-第四版》作者的E-mail地址为：fewstu@163.com。 

## 第 1 章 基础知识

​	汇编语言是直接在硬件之上工作的编程语言，我们首先要了解硬件系统的结构，才能有效地应用汇编语言对其编程。

​	在汇编课程中我们不对硬件系统进行全面和深入的研究，关于PC机及CPU物理结构和编程结构的全面研究，在《微机原理与接口》中进行；对于计算机一般的结构、功能、性能的研究在一门称为《组成原理》的理论层次更高的课程中进行。汇编课程的研究重点放在**如何利用硬件系统的编程结构和指令集有效灵活地控制系统进行工作**。

### 1.1 机器语言

​	机器语言是机器指令的集合。电子计算机的机器指令是一列**二进制数字**。计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算。

​	在我们常用的PC机中，有一个芯片来完成上面所说的计算机的功能。这个芯片就是我们常说的**CPU(Central Processing Unit,中央处理单元)**，CPU是一种微处理器。 以后我们提到的计算机是指由CPU和其他受CPU直接或间接控制的芯片、器件、设备组成的计算机系统，比如我们最常见的PC机。

​	每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使它工作。所以每一种微处理器都有自己的**机器指令集**，也就是机器语言。

​	早期的机器语言是0、1编写成的代码在纸带上打孔，机器码具有晦涩难懂和不易查错的缺点。

### 1.2 汇编语言的产生

​	汇编语言的主体是**汇编指令**。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式。

​	例如：机器指令`1000100111011000`表示把寄存器`BX`的内容送到`AX`中。汇编指令则写成 `mov ax，bx`。这样的写法与人类语言接近，便于阅读和记忆。

（寄存器，简单地讲是CPU中可以存储数据的器件，一个CPU中有多个寄存器。AX是其中一个寄存器的代号，BX是另一个寄存器的代号。）

​	此后，程序员们就用汇编指令编写源程序。计算机能读懂的只有机器指令，就需要有一个能够将汇编指令转换成机器指令的翻译程序，这样的程序我们称其为**编译器**。程序员用汇编语言写出源程序，再用汇编编译器将其编译为机器码，由计算机最终执行，如下图。

```mermaid
flowchart LR
    程序员 --> 汇编指令-->编译器-->机器码-->计算机
```

### 1.3 汇编语言的组成

汇编语言发展至今，有以下3类指令组成。

​	①汇编指令：机器码的助记符，有对应的机器码。

​	②伪指令：没有对应的机器码，由编译器执行，计算机并不执行。

​	③其他符号：如`+、—、*、/`等，由编译器识别，没有对应的机器码。

汇编语言的核心是汇编指令，它决定了汇编语言的特性。

### 1.4 存储器

​	CPU 是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在**存储器**中存放，也就是我们平时所说的**内存**。在一台PC机中内存的作用仅次于CPU，离开了内存，性能再好的CPU也无法工作。磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被CPU使用。要灵活地利用汇编语言编程，我们首先要了解 CPU 是如何从内存中读取信息，以及向内存中写入信息的。

### 1.5 指令和数据

​	指令和数据是应用上的概念。**在内存或磁盘上，指令和数据没有任何区别，都是二进制信息**。CPU在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。

​	例如，内存中的二进制信息`1000100111011000`，计算机可以把它看作大小为`89D8H`的数据来处理，也可以将其看作指令`mov ax，bx `来执行。

`1000100111011000—>89D8H（数据）`

`1000100111011000 -> mov ax,bx(程序) `

### 1.6 存储单元

​	存储器被划分成若干个存储单元，每个存储单元从 0 开始顺序编号，例如一个存储器有128个存储单元，编号从0～127，如图所示。这些编号可以看成存储单元在存储器中的地址

| 0    | 1    | 2    | 3    | 4    | ... ... | 124  | 125  | 126  | 127  |
| ---- | ---- | ---- | ---- | ---- | ------- | ---- | ---- | ---- | ---- |

​	那么一个存储单元能存储多少信息呢？电子计算机的最小信息单位是 bit（音译为比特），也就是一个二进制位。8 个 bit 组成一个 Byte，也就是通常讲的一个字节。微型机存储器的存储单元可以存储一个Byte，即 8 个二进制位。一个存储器有 128 个存储单元，它可以存储 128 个 Byte。

​	微机存储器的容量是以字节为最小单位来计算的。对于拥有 128 个存储单元的存储器，它的容量是128 个字节。

​	对于大容量的存储器一般还用以下单位来计量容量（以下用 B 来代表 Byte）：

​	1KB=1024B	1MB=1024KB	1GB=1024MB	1TB=1024GB

​	磁盘的容量单位同内存的一样，实际上以上单位是微机中常用的计量单位。

###  1.7 CPU对存储器的读写

​	CPU要从内存中读数据，首先要指定存储单元的地址。也就是说它要先确定它要读取哪一个存储单元中的数据。

​	另外，在一台微机中，不只有存储器这一种器件。CPU在读写数据时还要指明，它要对哪一个器件进行操作，进行哪种操作，是从中读出数据，还是向里面写入数据。

​	可见，CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行下面3类信息的交互。

* 存储单元的地址（地址信息）；

* 器件的选择，读或写的命令（控制信息）；
* 读或写的数据（数据信息）。

​	在计算机中专门有连接CPU和其他芯片的导线，通常称为**总线**。总线从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为3类，**地址总线**、**控制总线**和**数据总线**。

![1.3 CPU从内存中3号单元读取数据的过程](文档插图/1.3 CPU从内存中3号单元读取数据的过程.png)

<center style="color:#C0C0C0">图1.3 CPU从内存中3号单元读取数据的过程</center>

​	①CPU通过地址线将地址信息3发出。

​	②CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。

​	③存储器将3号单元中的数据8通过数据线送入CPU。

写操作与读操作的步骤相似。如向3号单元写入数据26。

​	①CPU通过地址线将地址信息3发出。

​	②CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。

​	③CPU通过数据线将数据26送入内存的3号单元中。

从上面我们知道了CPU是如何进行数据读写的。可是，如何命令计算机进行数据的读写呢？

要让一个计算机或微处理器工作，应向它输入能够驱动它进行工作的电平信息（机器码）。对于8086CPU，下面的机器码，能够完成从3号单元读数据。

​	机器码：`101000010000001100000000 `

​	对应的汇编指令：`MOV AX，[3]`

​	含义：从3号单元读取数据送入寄存器AX

CPU接收这条机器码后将完成我们上面所述的读写工作。

### 1.8 地址总线

​	CPU是通过地址总线来指定存储器单元的。可见地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。

​	现假设，一个CPU有10根地址总线，让我们来看一下它的寻址情况。我们知道，在电子计算机中，一根导线可以传送的稳定状态只有两种，高电平或是低电平。用二进制表示就是1或0，10根导线可以传送10位二进制数据。而10位二进制数可以表示多最小数为0，最大数为$2^{10} $ = 1023。

​	下图展示了一个具有10根地址线的CPU向内存发出地址信息11时10根地址线上传送的二进制信息。考虑一下，访问地址为12、13、14等的内存单元时，地址总线上传送的内容是 **0011000000、1011000000、0111000000**。

![1.8 地址线上传送的二进制信息](文档插图/1.8 地址线上传送的二进制信息.png)

<center style="color:#C0C0C0">图1.8 地址线上传送的二进制信息</center>

​	一个CPU有N根地址线，则可以说这个CPU的地址**总线的宽度为N**。这样的CPU最多可以寻找2的N次方个内存单元。

### 1.9 数据总线

​	CPU 与内存或其他器件之间的数据传送是通过**数据总线**来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。8根数据总线一次可传送一个8位二进制数据（即一个字节）。16根数据总线一次可传送两个字节。

​	8088CPU的数据总线宽度为8，8086CPU的数据总线宽度为16。我们来分别看一下它们向内存中写入数据89D8H时，是如何通过数据总线传送数据的。图1.9.1展示了8088CPU数据总线上的数据传送情况；图1.9.2展示了8086CPU数据总线上的数据传送情况。

![1.9.1 8088CPU数据总线上的数据传送情况](文档插图/1.9.1 8088CPU数据总线上的数据传送情况.png)

<center style="color:#C0C0C0">图1.9.1 8088CPU 8位数据总线上的数据传送情况</center>

![1.9.2 8086CPU数据总线上的数据传送情况](文档插图/1.9.2 8086CPU数据总线上的数据传送情况.png)

<center style="color:#C0C0C0">图1.9.2 8086CPU 16位数据总线上的数据传送情况</center>

​	8086有16根数据线，可一次传送16位数据，所以可一次传送数据89D8H；而8088只有8根数据线，一次只能传8位数据，所以向内存写入数据89D8H时需要进行两次数据传送。

### 1.10 控制总线

​	CPU对外部器件的控制是通过**控制总线**来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。

​	前面所讲的内存读或写命令是由几根控制线综合发出的，其中有一根称为“读信号输出”的控制线负责由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据；有一根称为“写信号输出”的控制线则负责传送写信号。

### 1.1 检测点与小结

#### 小结

> (1)汇编指令是机器指令的助记符，同机器指令一一对应。 
>
> (2)每一种CPU都有自己的汇编指令集。
>
> (3)CPU可以直接使用的信息在存储器中存放。
>
> (4)在存储器中指令和数据没有任何区别，都是二进制信息。 
>
> (5)存储单元从零开始顺序编号。
>
> (6)一个存储单元可以存储8个bit，即8位二进制数。
>
> (7)1Byte = 8bit	1KB = 1024B	1MB = 1024KB	1GB = 1024MB。
>
> (8)每一个CPU芯片都有许多**管脚**，这些管脚和总线相连。也可以说，这些管脚引出总线。一个 CPU可以引出3种总线的宽度标志了这个CPU的不同方面的性能：
>
> ​	地址总线的宽度决定了CPU的寻址能力；
>
> ​	数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量： 
>
> ​	控制总线的宽度决定了CPU对系统中其他器件的控制能力。
>
> 在汇编课程中，我们从功能的角度介绍了3类总线，对实际的连接情况不做讨论。 

#### 检测点

(1)1个CPU的寻址能力为8KB，那么它的地址总线的宽度为`13`。

(2)1KB的存储器有`1024`个存储单元。存储单元的编号从`0`到`1023`

(3)1KB的存储器可以存储`8192`个 bit,`1024`个 Byte。

(4)1GB、1MB、1KB分别是`2^30、2^20、2^10`Byte.

(5)8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则它们的寻址能力分别为：

`64`(KB)、`1`(MB)、`16`(MB)、`4`(GB)。

(6)8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为：`1`（B）、`1`（B）、`2`（B）、`2`（B）、`4`（B）。

(7)从内存中读取1024字节的数据，8086至少要读`512`次，80386至少要读`256`次。

(8)在存储器中，数据和程序以`二进制`形式存放。 

### 1.11 内存地址空间（概述）

​	什么是内存地址空间呢？举例来讲，一个CPU的地址总线宽度为10，那么可以寻址1024个内存单元，这**1024个可寻到的内存单元**就构成这个CPU的**内存地址空间**。

### 1.12 主板

​	在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有CPU、存储器、外围芯片组、扩展插槽等。扩展插槽上一般插有RAM内存条和各类接口卡。

### 1.13 接口卡

​	计算机系统中，所有可用程序控制其工作的设备，必须受到CPU的控制。CPU对外部设备都不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连。CPU可以**直接控制这些接口卡**，从而实现CPU**对外设的间接控制**。简单地讲，就是CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作。

### 1.14 各类存储器芯片

​	一台PC机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的、不同的器件。从读写属性上看分为两类：**随机存储器（RAM）**和**只读存储器（ROM）**。随机存储器**可读可写**，但必须**带电存储**，关机后存储的内容丢失；只读存储器**只能读取不能写入**，**关机后其中的内容不丢失**。这些存储器从功能和连接上又可分为以下几类。

* **随机存储器**

​	用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM组成，装在主板上的RAM和插在扩展插槽上的RAM。

* **装有BIOS(Basic Input/Output System,基本输入/输出系统)的ROM**

​	BIOS是由主板和各类接口卡（如显卡、网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。例如，主板上的ROM中存储着主板的BIOS（通常称为系统BIOS）；显卡上的ROM中存储着显卡的BIOS；如果网卡上装有ROM，那其中就可以存储网卡的BIOS。

* **接口卡上的RAM**

​	某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有RAM。最典型的是显示卡上的RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。

![1.14 PC系统中各类存储器的逻辑连接情况](文档插图/1.14 PC系统中各类存储器的逻辑连接情况.png)

<center style="color:#C0C0C0">图1.14 PC系统中各类存储器的逻辑连接情况。</center>

### 1.15 内存地址空间

上述的那些存储器，在物理上是独立的器件，但是在以下两点上相同。

* 都和CPU的总线相连。

* CPU对它们进行读或写的时候都通过控制线发出内存读写命令。

​	这也就是说，CPU在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的**内存地址空间**。在汇编这门课中，我们所面对的是内存地址空间。

![1.15 CPU将系统中各类存储器看作一个逻辑存储器](文档插图/1.15 CPU将系统中各类存储器看作一个逻辑存储器.png)

<center style="color:#C0C0C0">图1.15 CPU将系统中各类存储器看作一个逻辑存储器</center>

​	在上图中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即**一段地址空间**。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。

假设，图1.8中的内存地址空间的地址段分配如下。

​	地址0～7FFFH的32KB空间为主随机存储器的地址空间；

​	地址8000H～9FFFH的8KB空间为显存地址空间；

​	地址A000H～FFFFH的24KB空间为各个ROM的地址空间。

这样，CPU向内存地址为1000H的内存单元中写入数据，这个数据就被写入主随机存储器中；CPU向内存地址为8000H的内存单元中写入数据，这个数据就被写入显存中，然后会被显卡输出到显示器上；CPU向内存地址为C000H的内存单元中写入数据的操作是没有结果的，C000H单元中的内容不会被改变，C000H单元实际上就是ROM存储器中的一个单元。

​	内存地址空间的大小受CPU地址总线宽度的限制。8086CPU的地址总线宽度为20，可以传送$2^{20}$个不同的地址信息（大小从0至$2^{20}-1$）。即可以定位$2^{20}$个内存单元，则8086PC的内存地址空间大小为1MB。同理，80386CPU的地址总线宽度为32，则内存地址空间最大为4GB。

​	我们在基于一个计算机硬件系统编程的时候，必须知道这个系统中的**内存地址空间分配情况**。因为当我们想在某类存储器中读写数据的时候，必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作是在预期的存储器中进行。比如，我们希望向显示器输出一段信息，那么必须将这段信息写到显存中，显卡才能将它输出到显示器上。要向显存中写入数据，必须知道显存在内存地址空间中的地址。

​	不同的计算机系统的内存地址空间的分配情况是不同的，图1.15.1 展示了8086PC机内存地址空间分配的基本情况。

![1.15.1 8086PC机内存地址空间分配](文档插图/1.15.1 8086PC机内存地址空间分配.png)

<center style="color:#C0C0C0">图1.15.1 8086PC机内存地址空间分配</center>

​	上图告诉我们，从地址0～9FFFF的内存单元中读取数据，实际上就是在读取主随机存储器中的数据；向地址A0000～BFFFF的内存单元中写数据，就是向显存中写入数据，这些数据会被显示卡输出到显示器上；我们向地址C0000～FFFFF的内存单元中写入数据的操作是无效的，因为这等于改写只读存储器中的内容。

#### 内存地址空间

​	最终运行程序的是CPU，我们用汇编语言编程的时候，必须要从CPU的角度考虑问题。对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的**内存地址空间**。

​	对于初学者，这个概念比较抽象，后续的课程中将通过一些编程实践，来增加感性认识。

