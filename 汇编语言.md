# 汇编语言

## 序章 前言

### 1.1 教学思想

​	一门课程是由相互关联的知识构成的，这些知识在一本书中如何组织则是一种信息组织和加工的艺术。学习是一个循序渐进的过程，但并不是所有的教学都是以这种方式完成的，这并不是我们所希望看到的事情，因为任何不以循序渐进的方式进行的学习，都将出现盲目探索和不成系统的情况，最终学习到的也大都是相对零散的知识，并不能建立起一个系统的知识结构。非循序渐进的学习，也达不到循序渐进学习所能达到的深度，因为后者是步步深入的，每一步都以前一步为基础。

​	为学习者构造合理的学习线索，这个学习线索应真正地遵循**循序渐进**的原则。我们需要打破传统的章节划分，以一种新的艺术来对课程的内容进行补充、分割、重组，使其成为一个个串联在学习线索上的完成特定教学功能的教学节点。本书以此作为创作的核心理念，打破了传统的章节划分，构造了合理的学习线索，将课程的内容拆解到学习线索中的各个教学节点中去。学习主线索上的教学节点有4类：①知识点（即各小节内容）；②检测点；③问题和分析；④实验。还有一种被称为附注的教学节点不在学习主线索之中，是由知识点引出的节点，属于选看内容。

​	为了按循序渐进的原则构造学习线索，本书采用了一种全新的信息组织和加工艺术，我们称其为**知识屏蔽**。有的教材只注重知识的授予，并不注重知识的屏蔽。在教学中知识的屏蔽十分重要，这是一个重点突出的问题。计算机是一门交叉学科，一部分知识往往还连带着其他的相关内容，这些连带的相关内容如果处理不好，将影响学习者对目前要掌握的知识的理解。本书采用了知识屏蔽的方法，对教学内容进行了最小化分割，力求使我们在学习过程中所接触到的每一个知识点都是当前唯一要去理解的东西。我们在看到这个知识点之前，已理解了以前所有的内容；在学习这个知识点的过程中，以后的知识也不会对我们造成干扰。我们在整个学习过程中，每一步都走得清楚而扎实，不知不觉中，由当初的一个简单的问题开始，在经历了一个每一步都相对简单的过程之后，被带入了一个深的层次。这同沿着楼梯上高楼一样，迈出的每一步都不高，结果却上了楼顶。

### 1.2 本书的结构

本书由若干章构成，一章包含若干知识点，根据具体内容，还可能包含检测点、问题和分析、实验、附注等教学节点。书中的所有教学节点，除附注之外，都在一个全程的主线索之中。

由于本书具有很强的线索性，学习一定要按照教学的线索进行，有两点是必须要遵守的原则：①没有通过检测点不要向下学习；②没有完成当前的实验不要向下学习。

下面的表格详细说明了书中的各种教学节点和它们的组织情况。

<center style="color:#C0C0C0">表 教学节点详表</center>

| 教学节点 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 知识点   | 学习者的主要知识来源。知识点以小节的形式出现，一个知识点为一个小节。每一个知识点都有一个相对独立的小主题。 |
| 附注     | 有些内容是对主要内容的拓展、加深和补充。这些内容如果放入正文中，会分散学习者对主体内容的注意力，同时也破坏了主体内容的系统性。我们把这些内容在附注中给出，供学习者选看。附注不在主线索之中，是主线索的引出内容。 |
| 检测点   | 检测点用来取得学习情况的反馈。只要通过了检测点，我们就得到了一个保证：已掌握了前面的内容。这是对学习成果的阶段性的肯定，有了这个肯定，可以信心十足地继续学习。如果没有通过检测点，需要回头再进行复习。有的检测点中也包含了一些具有教学功能的内容。 |
| 问题分析 | 引导学习者对知识进行深入的理解和灵活的应用。                 |
| 实验     | 在本书中，实验也是在学习线索中的。有的教学内容就包含在编程的依据材料中。每一实验个实验都是后续内容的基础，实验的任务必须独立完成。我们可以这样看待实验的重要性，如果你没有完成当前的实验，就应停止继续学习，直到你独立完成实验。 |

### 1.3 教学重心和内容特点

本书的教学重心是：通过**学习关键指令来深入理解机器工作的基本原理，培养底层编程意识和思想**。本着这个原则，本书的内容将和传统的教材有着很大的不同。

​	(1)不讲解每一条指令的功能

​	指令仅仅是学习机器基本原理和设计思想的一种实例。而逐条地讲解每一条指令的功能，不是本书的职责所在，它应该是一本指令手册的核心内容。这就好像文学作品和字典的区别，前者的重心在于用文字表达思想，后者讲解每个字的用法。

​	(2)编程的平台是硬件而不是操作系统

​	这一点尤为重要，直接影响以后的操作系统的教学。我们必须通过一定的编程实践，体验一个裸机的环境，在一个没有操作系统的环境中直接对硬件编程。这样的体会和经验非常重要，这样我们才能真正体会到汇编语言的作用，并且看到没有操作系统的计算机系统是怎样的。这为以后的操作系统的学习打下了一个重要的基础。

​	(3)着重讲解重要指令和关键概念

​	本书的所有内容都是围绕着“深入理解机器工作的基本原理”和“培养底层编程意识和思想”这两个核心目标来进行的。对所有和这两个目标关系并不密切的内容，都进行了舍弃。使学习者可以集中注意力真正理解和掌握那些具有普遍意义的指令和关键概念。

​	本书在深入到本质的层面上对重要指令和关键概念进行了讲解和讨论。这些指令和概念有：jmp、条件转移指令、call、ret、栈指令、int、iret、cmp、loop、分段、寻址方式等。 

### 1.4 读者定位

​	本书可用作大学计算机专业本科的汇编教材，和希望深入学习计算机科学的学习者的自学教材。本书的读者应具备以下基础：

​	①具有计算机的使用经验；

​	②具有二进制、十六进制等基础知识；

​	③具有一门高级语言（BASIC、Pascal、C...）的基本编程基础。

### 1.5 联系方法

​	《汇编语言-第四版》作者的E-mail地址为：fewstu@163.com。 

## 第 1 章 基础知识

​	汇编语言是直接在硬件之上工作的编程语言，我们首先要了解硬件系统的结构，才能有效地应用汇编语言对其编程。

​	在汇编课程中我们不对硬件系统进行全面和深入的研究，关于PC机及CPU物理结构和编程结构的全面研究，在《微机原理与接口》中进行；对于计算机一般的结构、功能、性能的研究在一门称为《组成原理》的理论层次更高的课程中进行。汇编课程的研究重点放在**如何利用硬件系统的编程结构和指令集有效灵活地控制系统进行工作**。

### 1.1 机器语言

​	机器语言是机器指令的集合。电子计算机的机器指令是一列**二进制数字**。计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算。

​	在我们常用的PC机中，有一个芯片来完成上面所说的计算机的功能。这个芯片就是我们常说的**CPU(Central Processing Unit,中央处理单元)**，CPU是一种微处理器。 以后我们提到的计算机是指由CPU和其他受CPU直接或间接控制的芯片、器件、设备组成的计算机系统，比如我们最常见的PC机。

​	每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使它工作。所以每一种微处理器都有自己的**机器指令集**，也就是机器语言。

​	早期的机器语言是0、1编写成的代码在纸带上打孔，机器码具有晦涩难懂和不易查错的缺点。

### 1.2 汇编语言的产生

​	汇编语言的主体是**汇编指令**。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式。

​	例如：机器指令`1000100111011000`表示把寄存器`BX`的内容送到`AX`中。汇编指令则写成 `mov ax，bx`。这样的写法与人类语言接近，便于阅读和记忆。

（寄存器，简单地讲是CPU中可以存储数据的器件，一个CPU中有多个寄存器。AX是其中一个寄存器的代号，BX是另一个寄存器的代号。）

​	此后，程序员们就用汇编指令编写源程序。计算机能读懂的只有机器指令，就需要有一个能够将汇编指令转换成机器指令的翻译程序，这样的程序我们称其为**编译器**。程序员用汇编语言写出源程序，再用汇编编译器将其编译为机器码，由计算机最终执行，如下图。

```mermaid
flowchart LR
    程序员 --> 汇编指令-->编译器-->机器码-->计算机
```

### 1.3 汇编语言的组成

汇编语言发展至今，有以下3类指令组成。

​	①汇编指令：机器码的助记符，有对应的机器码。

​	②伪指令：没有对应的机器码，由编译器执行，计算机并不执行。

​	③其他符号：如`+、—、*、/`等，由编译器识别，没有对应的机器码。

汇编语言的核心是汇编指令，它决定了汇编语言的特性。

### 1.4 存储器

​	CPU 是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个CPU工作，就必须向它提供指令和数据。指令和数据在**存储器**中存放，也就是我们平时所说的**内存**。在一台PC机中内存的作用仅次于CPU，离开了内存，性能再好的CPU也无法工作。磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被CPU使用。要灵活地利用汇编语言编程，我们首先要了解 CPU 是如何从内存中读取信息，以及向内存中写入信息的。

### 1.5 指令和数据

​	指令和数据是应用上的概念。**在内存或磁盘上，指令和数据没有任何区别，都是二进制信息**。CPU在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。

​	例如，内存中的二进制信息`1000100111011000`，计算机可以把它看作大小为`89D8H`的数据来处理，也可以将其看作指令`mov ax，bx `来执行。

`1000100111011000—>89D8H（数据）`

`1000100111011000 -> mov ax,bx(程序) `

### 1.6 存储单元

​	存储器被划分成若干个存储单元，每个存储单元从 0 开始顺序编号，例如一个存储器有128个存储单元，编号从0～127，如图所示。这些编号可以看成存储单元在存储器中的地址

| 0    | 1    | 2    | 3    | 4    | ... ... | 124  | 125  | 126  | 127  |
| ---- | ---- | ---- | ---- | ---- | ------- | ---- | ---- | ---- | ---- |

​	那么一个存储单元能存储多少信息呢？电子计算机的最小信息单位是 bit（音译为比特），也就是一个二进制位。8 个 bit 组成一个 Byte，也就是通常讲的一个字节。微型机存储器的存储单元可以存储一个Byte，即 8 个二进制位。一个存储器有 128 个存储单元，它可以存储 128 个 Byte。

​	微机存储器的容量是以字节为最小单位来计算的。对于拥有 128 个存储单元的存储器，它的容量是128 个字节。

​	对于大容量的存储器一般还用以下单位来计量容量（以下用 B 来代表 Byte）：

​	1KB=1024B	1MB=1024KB	1GB=1024MB	1TB=1024GB

​	磁盘的容量单位同内存的一样，实际上以上单位是微机中常用的计量单位。

###  1.7 CPU对存储器的读写

​	CPU要从内存中读数据，首先要指定存储单元的地址。也就是说它要先确定它要读取哪一个存储单元中的数据。

​	另外，在一台微机中，不只有存储器这一种器件。CPU在读写数据时还要指明，它要对哪一个器件进行操作，进行哪种操作，是从中读出数据，还是向里面写入数据。

​	可见，CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行下面3类信息的交互。

* 存储单元的地址（地址信息）；

* 器件的选择，读或写的命令（控制信息）；
* 读或写的数据（数据信息）。

​	在计算机中专门有连接CPU和其他芯片的导线，通常称为**总线**。总线从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为3类，**地址总线**、**控制总线**和**数据总线**。

![1.3 CPU从内存中3号单元读取数据的过程](文档插图/1.3 CPU从内存中3号单元读取数据的过程.png)

<center style="color:#C0C0C0">图1.3 CPU从内存中3号单元读取数据的过程</center>

​	①CPU通过地址线将地址信息3发出。

​	②CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。

​	③存储器将3号单元中的数据8通过数据线送入CPU。

写操作与读操作的步骤相似。如向3号单元写入数据26。

​	①CPU通过地址线将地址信息3发出。

​	②CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，要向其中写入数据。

​	③CPU通过数据线将数据26送入内存的3号单元中。

从上面我们知道了CPU是如何进行数据读写的。可是，如何命令计算机进行数据的读写呢？

要让一个计算机或微处理器工作，应向它输入能够驱动它进行工作的电平信息（机器码）。对于8086CPU，下面的机器码，能够完成从3号单元读数据。

​	机器码：`101000010000001100000000 `

​	对应的汇编指令：`MOV AX，[3]`

​	含义：从3号单元读取数据送入寄存器AX

CPU接收这条机器码后将完成我们上面所述的读写工作。

### 1.8 地址总线

​	CPU是通过地址总线来指定存储器单元的。可见地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。

​	现假设，一个CPU有10根地址总线，让我们来看一下它的寻址情况。我们知道，在电子计算机中，一根导线可以传送的稳定状态只有两种，高电平或是低电平。用二进制表示就是1或0，10根导线可以传送10位二进制数据。而10位二进制数可以表示多最小数为0，最大数为$2^{10} $ = 1023。

​	下图展示了一个具有10根地址线的CPU向内存发出地址信息11时10根地址线上传送的二进制信息。考虑一下，访问地址为12、13、14等的内存单元时，地址总线上传送的内容是 **0011000000、1011000000、0111000000**。

![1.8 地址线上传送的二进制信息](文档插图/1.8 地址线上传送的二进制信息.png)

<center style="color:#C0C0C0">图1.8 地址线上传送的二进制信息</center>

​	一个CPU有N根地址线，则可以说这个CPU的地址**总线的宽度为N**。这样的CPU最多可以寻找2的N次方个内存单元。

### 1.9 数据总线

​	CPU 与内存或其他器件之间的数据传送是通过**数据总线**来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。8根数据总线一次可传送一个8位二进制数据（即一个字节）。16根数据总线一次可传送两个字节。

​	8088CPU的数据总线宽度为8，8086CPU的数据总线宽度为16。我们来分别看一下它们向内存中写入数据89D8H时，是如何通过数据总线传送数据的。图1.9.1展示了8088CPU数据总线上的数据传送情况；图1.9.2展示了8086CPU数据总线上的数据传送情况。

![1.9.1 8088CPU数据总线上的数据传送情况](文档插图/1.9.1 8088CPU数据总线上的数据传送情况.png)

<center style="color:#C0C0C0">图1.9.1 8088CPU 8位数据总线上的数据传送情况</center>

![1.9.2 8086CPU数据总线上的数据传送情况](文档插图/1.9.2 8086CPU数据总线上的数据传送情况.png)

<center style="color:#C0C0C0">图1.9.2 8086CPU 16位数据总线上的数据传送情况</center>

​	8086有16根数据线，可一次传送16位数据，所以可一次传送数据89D8H；而8088只有8根数据线，一次只能传8位数据，所以向内存写入数据89D8H时需要进行两次数据传送。

### 1.10 控制总线

​	CPU对外部器件的控制是通过**控制总线**来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。

​	前面所讲的内存读或写命令是由几根控制线综合发出的，其中有一根称为“读信号输出”的控制线负责由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据；有一根称为“写信号输出”的控制线则负责传送写信号。

### 1.a 检测点与小结

#### 小结

> (1)汇编指令是机器指令的助记符，同机器指令一一对应。 
>
> (2)每一种CPU都有自己的汇编指令集。
>
> (3)CPU可以直接使用的信息在存储器中存放。
>
> (4)在存储器中指令和数据没有任何区别，都是二进制信息。 
>
> (5)存储单元从零开始顺序编号。
>
> (6)一个存储单元可以存储8个bit，即8位二进制数。
>
> (7)1Byte = 8bit	1KB = 1024B	1MB = 1024KB	1GB = 1024MB。
>
> (8)每一个CPU芯片都有许多**管脚**，这些管脚和总线相连。也可以说，这些管脚引出总线。一个 CPU可以引出3种总线的宽度标志了这个CPU的不同方面的性能：
>
> ​	地址总线的宽度决定了CPU的寻址能力；
>
> ​	数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量： 
>
> ​	控制总线的宽度决定了CPU对系统中其他器件的控制能力。
>
> 在汇编课程中，我们从功能的角度介绍了3类总线，对实际的连接情况不做讨论。 

#### 检测点

(1)1个CPU的寻址能力为8KB，那么它的地址总线的宽度为`13`。

(2)1KB的存储器有`1024`个存储单元。存储单元的编号从`0`到`1023`

(3)1KB的存储器可以存储`8192`个 bit,`1024`个 Byte。

(4)1GB、1MB、1KB分别是`2^30、2^20、2^10`Byte.

(5)8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则它们的寻址能力分别为：

`64`(KB)、`1`(MB)、`16`(MB)、`4`(GB)。

(6)8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为：`1`（B）、`1`（B）、`2`（B）、`2`（B）、`4`（B）。

(7)从内存中读取1024字节的数据，8086至少要读`512`次，80386至少要读`256`次。

(8)在存储器中，数据和程序以`二进制`形式存放。 

### 1.11 内存地址空间（概述）

​	什么是内存地址空间呢？举例来讲，一个CPU的地址总线宽度为10，那么可以寻址1024个内存单元，这**1024个可寻到的内存单元**就构成这个CPU的**内存地址空间**。

### 1.12 主板

​	在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有CPU、存储器、外围芯片组、扩展插槽等。扩展插槽上一般插有RAM内存条和各类接口卡。

### 1.13 接口卡

​	计算机系统中，所有可用程序控制其工作的设备，必须受到CPU的控制。CPU对外部设备都不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连。CPU可以**直接控制这些接口卡**，从而实现CPU**对外设的间接控制**。简单地讲，就是CPU通过总线向接口卡发送命令，接口卡根据CPU的命令控制外设进行工作。

### 1.14 各类存储器芯片

​	一台PC机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的、不同的器件。从读写属性上看分为两类：**随机存储器（RAM）**和**只读存储器（ROM）**。随机存储器**可读可写**，但必须**带电存储**，关机后存储的内容丢失；只读存储器**只能读取不能写入**，**关机后其中的内容不丢失**。这些存储器从功能和连接上又可分为以下几类。

* **随机存储器**

​	用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM组成，装在主板上的RAM和插在扩展插槽上的RAM。

* **装有BIOS(Basic Input/Output System,基本输入/输出系统)的ROM**

​	BIOS是由主板和各类接口卡（如显卡、网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。例如，主板上的ROM中存储着主板的BIOS（通常称为系统BIOS）；显卡上的ROM中存储着显卡的BIOS；如果网卡上装有ROM，那其中就可以存储网卡的BIOS。

* **接口卡上的RAM**

​	某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有RAM。最典型的是显示卡上的RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。

![1.14 PC系统中各类存储器的逻辑连接情况](文档插图/1.14 PC系统中各类存储器的逻辑连接情况.png)

<center style="color:#C0C0C0">图1.14 PC系统中各类存储器的逻辑连接情况。</center>

### 1.15 内存地址空间

上述的那些存储器，在物理上是独立的器件，但是在以下两点上相同。

* 都和CPU的总线相连。

* CPU对它们进行读或写的时候都通过控制线发出内存读写命令。

​	这也就是说，CPU在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的**内存地址空间**。在汇编这门课中，我们所面对的是内存地址空间。

![1.15 CPU将系统中各类存储器看作一个逻辑存储器](文档插图/1.15 CPU将系统中各类存储器看作一个逻辑存储器.png)

<center style="color:#C0C0C0">图1.15 CPU将系统中各类存储器看作一个逻辑存储器</center>

​	在上图中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即**一段地址空间**。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。

假设，图1.8中的内存地址空间的地址段分配如下。

​	地址0～7FFFH的32KB空间为主随机存储器的地址空间；

​	地址8000H～9FFFH的8KB空间为显存地址空间；

​	地址A000H～FFFFH的24KB空间为各个ROM的地址空间。

这样，CPU向内存地址为1000H的内存单元中写入数据，这个数据就被写入主随机存储器中；CPU向内存地址为8000H的内存单元中写入数据，这个数据就被写入显存中，然后会被显卡输出到显示器上；CPU向内存地址为C000H的内存单元中写入数据的操作是没有结果的，C000H单元中的内容不会被改变，C000H单元实际上就是ROM存储器中的一个单元。

​	内存地址空间的大小受CPU地址总线宽度的限制。8086CPU的地址总线宽度为20，可以传送$2^{20}$个不同的地址信息（大小从0至$2^{20}-1$）。即可以定位$2^{20}$个内存单元，则8086PC的内存地址空间大小为1MB。同理，80386CPU的地址总线宽度为32，则内存地址空间最大为4GB。

​	我们在基于一个计算机硬件系统编程的时候，必须知道这个系统中的**内存地址空间分配情况**。因为当我们想在某类存储器中读写数据的时候，必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作是在预期的存储器中进行。比如，我们希望向显示器输出一段信息，那么必须将这段信息写到显存中，显卡才能将它输出到显示器上。要向显存中写入数据，必须知道显存在内存地址空间中的地址。

​	不同的计算机系统的内存地址空间的分配情况是不同的，图1.15.1 展示了8086PC机内存地址空间分配的基本情况。

![1.15.1 8086PC机内存地址空间分配](文档插图/1.15.1 8086PC机内存地址空间分配.png)

<center style="color:#C0C0C0">图1.15.1 8086PC机内存地址空间分配</center>

​	上图告诉我们，从地址0～9FFFF的内存单元中读取数据，实际上就是在读取主随机存储器中的数据；向地址A0000～BFFFF的内存单元中写数据，就是向显存中写入数据，这些数据会被显示卡输出到显示器上；我们向地址C0000～FFFFF的内存单元中写入数据的操作是无效的，因为这等于改写只读存储器中的内容。

#### 内存地址空间

​	最终运行程序的是CPU，我们用汇编语言编程的时候，必须要从CPU的角度考虑问题。对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的**内存地址空间**。

​	对于初学者，这个概念比较抽象，后续的课程中将通过一些编程实践，来增加感性认识。

## 第 2 章 寄存器

​	一个典型的CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前一章所说的总线，相对于CPU内部来说是**外部总线**。**内部总线**实现**CPU内部各个器件之间的联系**，外部总线实现CPU和主板上其他器件的联系。简单地说，在CPU中：

* 运算器进行信息处理
* 寄存器进行信息存储

* 控制器控制各种器件进行工作

* 内部总线连接各种器件，在它们之间进行数据的传送

对于一个汇编程序员来说，CPU中的主要部件是寄存器。寄存器是CPU中程序员可以用指令读写的部件。程序员通过改变各种寄存器中的内容来实现对CPU的控制。

​	不同的CPU，寄存器的个数、结构是不相同的。8086CPU有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、 DS、ES、PSW。

### 2.1 通用寄存器

8086CPU的所有寄存器都是16位的，可以存放两个字节。AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。

以AX为例，寄存器的逻辑结构如下图所示。

![2.1 16位寄存器的逻辑结构](文档插图/2.1 16位寄存器的逻辑结构.png)

<center style="color:#C0C0C0">图2.1 16位寄存器的逻辑结构</center>

​	一个16位寄存器可以存储一个16位的数据，数据在寄存器中的存放情况如图2.1.1所示。一个16位寄存器所能存储的数据的最大值为 $2^{16}-1$。

![2.1.1 16位数据在寄存器中的存放情况](文档插图/2.1.1 16位数据在寄存器中的存放情况.png)

<center style="color:#C0C0C0">图2.1.1 16位数据在寄存器中的存放情况</center>

​	8086CPU的上一代CPU中的寄存器都是8位的，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在8086之上，8086CPU的AX、BX、CX、DX这4个寄存器都**可分为两个可独立使用的8位寄存器**来用，AX的高8位字节部分记为AH，低8位字节部分记为AL，其他三个寄存器类似。

​	以AX为例，8086CPU的16位寄存器分为两个8位寄存器的情况如图 2.1.2 所示。

![2.1.2 16位寄存器分为两个8位寄存器](文档插图/2.1.2 16位寄存器分为两个8位寄存器.png)

<center style="color:#C0C0C0">图2.1.2 16位寄存器分为两个8位寄存器</center>

​	AX的低8位（0位～7位）构成了AL寄存器，高8位（8位～15位）构成了AH寄存器。AH和AL寄存器是可以独立使用的8位寄存器。下图2.1.3展示了16位寄存器及它所分成的两个8位寄存器的数据存储的情况，一个8位寄存器所能存储的数据的最大值为$2^8-1$。

![2.1.3 16位寄存器及所分成的两个8位寄存器的数据存储情况](文档插图/2.1.3 16位寄存器及所分成的两个8位寄存器的数据存储情况.png)

<center style="color:#C0C0C0">图2.1.3 16位寄存器及所分成的两个8位寄存器的数据存储情况</center>

### 2.2 字在寄存器中的存储

出于对兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据。

* 字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。

* 字：记为word，**一个字由两个字节组成**，这两个字节分别称为这个字的**高位字节**和**低位字节**，如图所示。

$$
字:\underset{高位字节}{\underbrace{01001110}}\underset{低位字节}{\underbrace{00100000}}
$$

​	一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中。如图2.1.3所示，一个字型数据20000，存在AX寄存器中，在AH中存储了它的高8位，在AL中存储了它的低8位。AH和AL中的数据，既可以看成是一个字型数据的高8位和低8位，这个字型数据的大小是20000，又可以看成是两个独立的字节型数据，它们的大小分别是78和32。

#### 关于数制的讨论

> ​	任何数据，到了计算机中都是以二进制的形式存放的。为了描述不同的问题，又经常将它们用其他的进制来表示。比如图2.1.3中寄存器AX中的数据是0100111000100000，这就是AX中的信息本身，可以用不同的逻辑意义来看待它。可以将它看作一个数值，大小是20000。
>
> ​	当然，二进制数0100111000100000本身也可表示一个数值的大小，但人类习惯的是十进制，用十进制20000表示可以使我们直观地感受到这个数值的大小。
>
> ​	十六进制数的一位相当于二进制数的四位，如0100111000100000可表示成：4（0100）、E（1110）、2（0010）、0（0000）四位十六进制数。
>
> ​	一个内存单元可存放8位数据，CPU中的寄存器又可存放n个8位的数据。也就是说，计算机中的数据大多是由1～N个8位数据构成的。很多时候，需要直观地看出组成数据的各个字节数据的值，用十六进制来表示数据可以直观地看出这个数据是由哪些8位数据构成的。比如20000写成4E20就可以直观地看出，这个数据是由4E和20两个8位数据构成的，如果AX中存放4E20，则AH里是4E，AL里是20。这种表示方法便于许多问题的直观分析。在以后的课程中，我们多用十六进制来表示一个数据。
>
> ​	在以后的课程中，为了区分不同的进制，在十六进制表示的数据的后面加H，在二进制表示的数据后面加B，十进制表示的数据后面什么也不加。如：可用3种不同的进制表示图2.1.3中AX里的数据，十进制：20000，十六进制：4E20H，二进制：0100111000100000B。

### 2.3 几条汇编指令

通过汇编指令控制CPU进行工作，看一下表2.1中的几条指令。

<center style="color:#C0C0C0">表2.3.1 汇编指令举例</center>

| 汇编指令  | 控制CPU完成的操作                  | 用C语言的语法描述 |
| --------- | ---------------------------------- | ----------------- |
| mov ax,18 | 将18送入寄存器AX                   | AX = 18           |
| mov ah,78 | 将78送入寄存器AH                   | AH = 78           |
| add ax,8  | 将寄存器AX中的数值加上8            | AX = AX + 8       |
| mov ax,bx | 将寄存器BX中的数据送入寄存器AX     | AX = BX           |
| add ax,bx | 将AX和BX中的数值相加，结果存在AX中 | AX = AX + BX      |

​	注意，为了使具有高级语言基础的读者更好地理解指令的含义，有时会用文字描述和高级语言描述这两种方式来描述一条汇编指令的含义。在**写一条汇编指令或一个寄存器的名称时不区分大小写**。

​	接下来看一下CPU执行表2.3.2中所列的程序段中的每条指令后，对寄存器中的数据进行的改变。

<center style="color:#C0C0C0">表2.3.2 程序段中指令的执行情况之一(原AX中的值：0000H，原BX中的值：0000H)</center>

| 程序段中的指令 | 指令执行后AX中的数据 | 指令执行后BX中的数据 |
| -------------- | -------------------- | -------------------- |
| mov ax,4E20H   | 4E20H                | 0000H                |
| add ax,1406H   | 6226H                | 0000H                |
| mov bx,2000H   | 6226H                | 2000H                |
| add ax,bx      | 8226H                | 2000H                |
| mov bx,ax      | 8226H                | 8226H                |
| add ax,bx      | `/*Answer*/`         | 8226H                |

#### 问题 2.1

上表`add ax,bx`指令执行后AX中的数据为多少？

分析：

​	程序段中的最后一条指令 add ax，bx，在执行前 ax 和 bx 中的数据都为 8226H，相加后所得的值为： 1044CH，但是ax为16位寄存器，只能存放4位十六进制的数据，所以最高位的 1不能在 ax中保存，ax中的数据为： 044CH

#### 问题 2.2

指令执行后AX中的数据为多少？

| 程序段中的指令 | 指令执行后AX中的数据 | 指令执行后BX中的数据 |
| -------------- | -------------------- | -------------------- |
| mov ax,001AH   | 001AH                | 0000H                |
| mov bx,0026H   | 001AH                | 0026H                |
| add al,bl      | 0040H                | 0026H                |
| add ah,bl      | 2640H                | 0026H                |
| add bh,al      | 2640H                | 4026H                |
| mov ah,0       | 0040H                | 4026H                |
| add al,85H     | 00C5H                | 4026H                |
| add al,93H     | `/*Answer*/`         | 4026H                |

分析：

​	程序段中的最后一条指令 `add al，93H`，在执行前，al 中的数据为 C5H，相加后所得的值为：158H，但是 al 为 8 位寄存器，只能存放两位十六进制的数据，所以最高位的 1 丢失， ax中的数据为： 0058H。 （这里的丢失，指的是进位值不能在 8 位寄存器中保存，但是CPU并不真的丢弃这个进位值，关于这个问题，我们将在后面的课程中讨论。）

​	注意，**此时 al 是作为一个独立的 8 位寄存器来使用的**，和 ah 没有关系，CPU 在执行这条指令时认为ah和al是两个不相关的寄存器。不要错误地认为，诸如add al，93H的指令产生的进位会存储在ah中，add al，93H进行的是8位运算。

​	如果执行add ax，93H，低8位的进位会存储在ah中，CPU在执行这条指令时认为只有一个16位寄存器ax，进行的是16位运算。指令add ax，93H执行后，ax中的值为：0158H。此时，使用的寄存器是16位寄存器ax，add ax，93H相当于将ax中的16位数据00C5H和另一个16位数据0093H相加，结果是16位的0158H。

​	在进行数据传送或运算时，要注意指令的两个操作对象的**位数应当是一致**的，例如：

```assembly
mov ax, bx
mov bx, cx 
mov ax, 18H
mov al, 18H
add ax, bx
add ax, 20000
```

等都是正确的指令，而：

```assembly
mov ax, bl   	/*在8位寄存器和16位寄存器之间传送数据*/
mov bh, ax		/*在16位寄存器和8位寄存器之间传送数据*/
mov al, 20000	/*8位寄存器最大可存放值为255的数据*/
add al, 100H		/*将一个高于8位的数据加到一个8位寄存器中*/
```

等都是错误的指令，错误的原因都是指令的两个操作对象的位数不一致。

### 2.a 检测点 

(1)写出每条汇编指令执行后相关寄存器中的值。 

| 汇编指令       | 寄存器中的值  |
| -------------- | ------------- |
| mov  ax, 62627 | AX = `F4A3H`  |
| mov ah, 31H    | AX =`31A3H` ★ |
| mov  al, 23H   | AX =`3123H`   |
| add  ax, ax    | AX =`6246H`   |
| mov  bx, 826CH | BX =`826CH`   |
| mov  cx, ax    | CX =`6246H`   |
| mov  ax, bx    | AX =`826CH`   |
| add  ax, bx    | AX =`04D8H`   |
| mov al,bh      | AX =`0482H`★  |
| mov ah,bl      | AX =`6C82H`★  |
| add ah,ah      | AX =`D882H`★  |
| add  al, 6     | AX =`D888H`   |
| add  al,al     | AX =`D810H`   |
| mov  ax,cx     | AX =`6246H`   |

(2)只能使用目前学过的汇编指令，最多使用4条指令，编程计算2的4次方。

```assembly
mov ax, 2
add ax, ax
add ax, ax
add ax, ax
```

### 2.4 物理地址

​	我们知道，CPU访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为**物理地址**。

​	CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的CPU可以有不同的形成物理地址的方式。我们现在讨论8086CPU是如何在内部形成内存单元的物理地址的。

### 2.5 16位结构的CPU

​	我们说8086CPU的上一代CPU（8080、8085）等是8位机，而8086是16位机，也可以说8086是16位结构的CPU。

​	16位结构的CPU概括地讲，16位结构（**16位机、字长为16位等常见说法，与16位结构的含义相同**）描述了一个CPU具有下面几方面的结构特性。

* 运算器一次最多可以处理16位的数据
* 寄存器的最大宽度为16位
* 寄存器和运算器之间的通路为16位

8086是16位结构的CPU，这也就是说，在8086内部，能够**一次性处理、传输、暂时存储的信息的最大长度是16位**的。内存单元的地址在送上地址总线之前，必须在CPU中处理、传输、暂时存放，对于16位CPU，能一次性处理、传输、暂时存储16位的地址。

### 2.6 8086CPU给出物理地址的方法

​	8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。

​	8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。

![2.6 8086CPU相关部件的逻辑结构](文档插图/2.6 8086CPU相关部件的逻辑结构.png)

 <center style="color:#C0C0C0">图2.6 8086CPU相关部件的逻辑结构</center>

​	8086CPU相关部件的逻辑结构如图2.6所示，当8086CPU要读写内存时：

​	①CPU中的相关部件提供两个16位的地址，一个称为**段地址**，另一个称为**偏移地址**

​	②段地址和偏移地址通过内部总线送入一个称为**地址加法器**的部件；

​	③地址加法器**将两个16位地址合成为一个20位的物理地址**；

​	④地址加法器通过内部总线将20位物理地址送入**输入输出控制电路**；

​	⑤输入输出控制电路将20位物理地址送上**地址总线**

​	⑥20位物理地址被地址总线传送到**存储器**。

​	地址加法器采用**物理地址 = 段地址×16 + 偏移地址**的方法用段地址和偏移地址合成物理地址。例如，8086CPU要访问地址为123C8H的内存单元，此时，地址加法器的工作过程如图2.6.1所示（图中数据皆为十六进制表示）。

 ![2.6.1 地址加法器的工作过程](文档插图/2.6.1 地址加法器的工作过程.png)



 <center style="color:#C0C0C0">图2.6.1 地址加法器的工作过程</center>

#### 由“段地址×16”引发的讨论

​	“段地址×16”有一个更为常用的说法是**左移4位**。计算机中的所有信息都是以二进制的形式存的，段地址当然也不例外。机器只能处理二进制信息，“左移4位”中的位，指的是二进制位。

​	下面是个例子，一个数据为2H，二进制形式为10B，对其进行左移运算：

| 左移位数 | 二进制  | 十六进制 | 十进制 |
| -------- | ------- | -------- | ------ |
| 0        | 10B     | 2H       | 2      |
| 1        | 100B    | 4H       | 4      |
| 2        | 1000B   | 8H       | 8      |
| 3        | 10000B  | 10H      | 16     |
| 4        | 100000B | 20H      | 32     |

 观察上面移位次数和各种形式数据的关系，我们可以发现：

1. 一个数据的二进制形式左移1位，相当于该数据乘以2；

2. 一个数据的二进制形式左移N位，相当于该数据乘以2的N次方：

3. 地址加法器如何完成段地址×16的运算？就是将以二进制形式存放的段地址左移4位。

​	进一步思考，我们可看出：一个数据的十六进制形式左移1位，相当于乘以16；一个数据的十进制形式左移1位，相当于乘以10；一个X进制的数据左移1位，相当于乘以X。

### 2.7 “段地址×16 + 偏移地址 = 物理地址”的本质含义

​	“段地址×16+偏移地址=物理地址”的本质含义是：**CPU在访问内存时，用一个基础地址（段地址×16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。**

​	更一般地说，8086CPU的这种寻址功能是“**基础地址 + 偏移地址 = 物理地址**”寻址模式的一种**具体实现方案**。8086CPU中，段地址×16可看作是基础地址。

​	实际上有两种方法可以把地址告诉你

1. 直接说明地址

2. 给出基础地址和偏移地址

​	8086CPU是16位结构，没法一次性给出20位地址，所以给出**基础地址 + 偏移地址**，根据事先约定就可以获得最终地址了。

### 2.8 段的概念

​	我们注意到，“段地址”这个名称中包含着“段”的概念。这种说法可能对一些学习者产生了误导，使人误以为内存被划分成了一个一个的段，每一个段有一个段地址。如果我们在一开始形成了这种认识，将影响以后对汇编语言的深入理解和灵活应用。

​	其实，**内存并没有分段，段的划分来自于CPU**，由于8086CPU用“**基础地址（段地址×16）+偏移地址=物理地址**”的方式给出内存单元的物理地址，使得我们可以**用分段的方式来管理内存**。如图2.8所示，我们可以认为：地址10000H～100FFH的内存单元组成一个段，该段的起始地址（基础地址）为10000H，段地址为1000H，大小为100H；我们也可以认为地址10000H～1007FH、10080H～100FFH的内存单元组成两个段，它们的起始地址（基础地址）为：10000H和10080H，段地址为：1000H和1008H，大小都为80H。

![2.8 分段](文档插图/2.8 分段.png)

 <center style="color:#C0C0C0">图2.8 分段</center>

​	以后，在编程时可以根据需要，**将若干地址连续的内存单元看作一个段**，用段地址×16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。有两点需要注意：段地址×16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；偏移地址为16位，16位地址的寻址能力为64KB，所以**一个段的长度最大为64KB**。

#### 内存单元地址小结

> CPU访问内存单元时，必须向内存提供内存单元的物理地址。8086CPU在内部用段地址和偏移地址 移位相加的方法形成最终的物理地址。
>
> 思考下面的两个问题。
>
> (1)观察下面的地址，你有什么发现？ 
>
> | 物理地址 | 段地址 | 偏移地址 |
> | -------- | ------ | -------- |
> | 21F60H   | 2000H  | 1F60H    |
> |          | 2100H  | 0F60H    |
> |          | 21F0H  | 0060H    |
> |          | 21F6H  | 0000H    |
> |          | 1F00H  | 2F60H    |
>
> 结论★：**CPU可用不同的段地址和偏移地址形成同一个物理地址**
>
> ​	比如CPU要访问21F60H单元，则它给出的段地址SA和偏移地址EA满足SA×16+EA=21F60H即可。
>
> (2)如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可定位多少个内存单元？
>
> 结论：偏移地址16位，变化范围为0～FFFFH，仅用偏移地址来寻址最多可寻64KB个内存单元。
>
> 比如给定段地址1000H，用偏移地址寻址，CPU的寻址范围为：10000H～1FFFFH。
>
> 在8086PC机中，存储单元的地址用两个元素来描述，即**段地址和偏移地址。**
>
> “数据在21F60H内存单元中。”这句话对于8086PC机一般不这样讲，取而代之的是两种类似的说法：
>
> ​	①数据存在内存2000:1F60单元中
>
> ​	②数据存在内存的2000H段中的1F60H单元中。
>
> **可以根据需要，将地址连续、起始地址为16的倍数的一组内存单元定义为一个段。**

###  2.b 检测点

（1）给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为`00010H`到`1000FH`

解析：偏移地址变化范围为0～FFFFH，寻址范围为段地址×16 + 偏移地址

（2）有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为`1001H`，最大为`2000H`。

（提示，反过来思考一下，当段地址给定为多少，CPU无论怎么变化偏移地址都无法寻到20000H单元？）

解析：段地址的最大值，可以用物理地址减去偏移地址的最小值；同理，段地址的最小值，可以用物理地址减去偏移地址的最大值。

20000H - 0H / 16 = 2000H

20000H - FFFFH = 10001H不能被16整除，取10010H / 16 = 1001H

当SA<=1000H或SA>2000H时，CPU无论怎么变化偏移地址都无法寻到20000H单元。

### 2.9 段寄存器

​	我们前面讲到，8086CPU在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。这里，需要看一下，是什么部件提供段地址。段地址在8086CPU的**段寄存器**中存放。8086CPU有4个段寄存器：CS(Code Segment)、DS(Data Segment)、SS(Stack Segment)、ES(Extra Segment)。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。本章中只看一下CS。

### 2.10 CS和IP

​	CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。**CS为代码段寄存器(Code Segment Register)**，**IP为指令指针寄存器(Instruction Pointer Register)**，从名称上我们可以看出它们和指令的关系。

在8086PC机中，任意时刻，设CS中的内容为M，IP中的内容为N，8086CPU将从内存M×16+N单元开始，读取一条指令并执行。

​	也可以这样表述：8086机中，任意时刻，**CPU将CS:IP指向的内容当作指令执行**。

​	图2.10展示了8086CPU读取、执行指令的工作原理（图中只包括了和所要说明的问题密切相关的部件，图中数字都为十六进制）。

![2.10 8086PC读取和执行指令的相关部件](文档插图/2.10 8086PC读取和执行指令的相关部件.png)

<center style="color:#C0C0C0">图2.10 8086PC读取和执行指令的相关部件</center>

图 2.10 说明如下。

​	①8086CPU当前状态：CS中的内容为2000H，IP 中的内容为 0000H

​	②内存 20000H～20009H 单元存放着可执行的机器码；

​	③内存 20000H～20009H 单元中存放的机器码对应的汇编指令如下。

​	地址： 20000H—20002H， 内容： B8 23 01，长度： 3Byte，对应汇编指令： mov ax，0123H

​	地址： 20003H—20005H， 内容： BB 03 00， 长度： 3Byte，对应汇编指令： mov bx，0003H

​	地址： 20006H—20007H，内容： 89 D8，长度： 2Byte，对应汇编指令： mov ax，bx

​	地址： 20008H—20009H，内容： 01 D8，长度： 2Byte，对应汇编指令： add ax，bx

下面的一组图（图1~图9），以图 2.10 描述的情况为初始状态，展示了 8086CPU读取、执行一条指令的过程。注意每幅图中发生的变化（下面对8086CPU的描述，是在逻辑结构、宏观过程的层面上进行的，目的是使读者对 CPU 工作原理有一个清晰、直观的认识，为汇编语言的学习打下基础。其中隐蔽了CPU的物理结构以及具体的工作细节）。

![2.10.1 初始状态](文档插图/2.10.1 初始状态.png)

![2.10.2 CSIP中内容送入地址加法器](文档插图/2.10.2 CSIP中内容送入地址加法器.png)

![2.10.3 地址加法器将物理地址送入输入输出控制电路](文档插图/2.10.3 地址加法器将物理地址送入输入输出控制电路.png)

![2.10.4 输入输出控制电路将物理地址送上地址总线](文档插图/2.10.4 输入输出控制电路将物理地址送上地址总线.png)

![2.10.5 内存单元存放的机器指令通过数据总线送入CPU](文档插图/2.10.5 内存单元存放的机器指令通过数据总线送入CPU.png)

![2.10.6 IO控制电路将机器指令送入指令缓冲器](文档插图/2.10.6 IO控制电路将机器指令送入指令缓冲器.png)

![2.10.7 IP中的值自增](文档插图/2.10.7 IP中的值自增.png)

（读取一条指令后，**IP中的值自动增加，以使CPU可以读取下一条指令**。因当前读入的指令B82301长度为3个字节，所以IP中的值加3。此时，CS:IP指向内存单元2000:0003。）

![2.10.8 执行控制器执行目标指令](文档插图/2.10.8 执行控制器执行目标指令.png)

![2.10.9 指令执行后寄存器中的内容](文档插图/2.10.9 指令执行后寄存器中的内容.png)

下面的一组图（图10～图16），以图9的情况为初始状态，展示了8086CPU继续读取、执行3条指令的过程。注意IP的变化（下面的描述中，隐蔽了读取每条指令的细节）。

![2.10.10 取新指令](文档插图/2.10.10 取新指令.png)

![2.10.11 指令放入指令缓冲器](文档插图/2.10.11 指令放入指令缓冲器.png)

![2.10.12 执行指令](文档插图/2.10.12 执行指令.png)

![2.10.13 从下一个内存单元读指令放入指令缓冲器](文档插图/2.10.13 从下一个内存单元读指令放入指令缓冲器.png)

![2.10.14 执行指令后寄存器中的内容](文档插图/2.10.14 执行指令后寄存器中的内容.png)

![2.10.15 读新指令放入指令缓冲器](文档插图/2.10.15 读新指令放入指令缓冲器.png)

![2.10.16 指令执行完毕后寄存器中的内容](文档插图/2.10.16 指令执行完毕后寄存器中的内容.png)

通过上面的过程展示，8086CPU 的工作过程可以简要描述如下：

1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；

2. IP=IP+所读取指令的长度，从而指向下一条指令；

3. 执行指令。转到步骤（1），重复这个过程。

​	在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH,IP=0000H,即在8086PC机刚启动时，CPU从内存FFFF0H单元中读取指令 执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。

​	现在，我们更清楚了CS和IP的重要性，它们的内容提供了CPU要执行指令的地址。

​	第1章中讲过，在内存中，指令和数据没有任何区别，都是二进制信息，CPU在工作的时候把有的信息看作指令，有的信息看作数据。现在，如果提出一个问题：<u>CPU根据什么将内存中的信息看作指令？如何回答？</u>我们可以说，**CPU将CS:IP指向的内存单元中的内容看作指令**，因为，在任何时候，**CPU将CS、IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行**。如果说，内存中的一段信息曾被CPU执行过的话，那么，它所在的内存单元必然被CS:IP指向过。

### 2.11 修改CS、IP的指令

​	在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制。CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS、IP中的内容来控制CPU执行目标指令。

​	8086CPU大部分寄存器的值，都可以用mov指令来改变，**mov指令**被称为**传送指令**。可以用mov指令，如mov ax，123将ax中的值设为123，显然，我们也可以用同样的方法设置其他寄存器的值。

​	但是，**mov指令不能用于设置CS、IP的值**，原因很简单，因为8086CPU没有提供这样的功能。8086CPU为CS、IP提供了另外的指令来改变它们的值。能够改变CS、IP的内容的指令被统称为**转移指令**。我们现在介绍一个最简单的可以修改CS、IP的指令：**jmp指令**。

* 若想同时修改CS、IP的内容，可用形如“jmp段地址:偏移地址”的指令完成，如

​	`jmp 2AE3:3`，执行后：CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令。 

​	`jmp3:0B16`，执行后：CS=0003H，IP=0B16H，CPU将从00B46H处读取指令。

​	“jmp段地址：偏移地址”指令的功能为：**用指令中给出的段地址修改CS，偏移地址修改IP**。

* 若想仅修改IP的内容，可用形如“jmp某一合法寄存器”的指令完成，如

​	`jmp ax`，指令执行前：ax=1000H，CS=2000H，IP=0003H

​			    指令执行后：ax=1000H，CS=2000H.IP=1000H

​	`jmp bx`，指令执行前：bx=0B16H， CS=2000H， IP=0003H

​			     指令执行后：bx=0B16H， CS=2000H， IP=0B16H

“jmp 某一合法寄存器”指令的功能为：**用寄存器中的值修改IP**

`jmp ax`，在含义上好似： `mov IP，ax`（注意，此处只是用于解释，实际并没有这种汇编指令）

#### 问题 2.3

​	内存中存放的机器码和对应的汇编指令情况如图 2.11 所示，设 CPU 初始状态：CS=2000H，IP=0000H，请写出指令执行序列。思考后看分析。

![2.11 内存中存放的机器码和对应的汇编指令](文档插图/2.11 内存中存放的机器码和对应的汇编指令.png)

<center style="color:#C0C0C0">图2.11 内存中存放的机器码和对应的汇编指令</center>

分析：

​	CPU对图2.11中的指令的执行过程如下：

​	①当前CS=2000H， IP=0000H，则CPU从内存 2000H×16+0=20000H 处读取指令，读入的指令是：B8 22 66（mov ax，6622H），读入后 IP=IP+3=0003H：

​	②指令执行后，CS=2000H， IP=0003H，则 CPU 从内存 2000H×16+0003H=20003H

处读取指令，读入的指令是：EA03000010（jmp1000：0003），读入后IP=IP+5=0008H：

​	③指令执行后，CS=1000H,IP=0003H,则CPU从内存1000H×16+0003H=10003H 处读取指令，读入的指令是：B8 00 00（mov ax，0000），读入后IP=IP+3=0006H：

​	④指令执行后，CS=1000H,IP=0006H,则CPU从内存1000H×16+0006H=10006H 处读取指令，读入的指令是：8BD8（mov bx，ax），读入后IP=IP+2=0008H；

​	⑤指令执行后，CS=1000H,IP=0008H,则CPU从内存1000H×16+0008H=10008H 处读取指令，读入的指令是：FFE3（jmp bx），读入后IP=IP+2=000AH：

​	⑥指令执行后，CS=1000H，IP=0000H，CPU从内存10000H处读取指令...

经分析后，可知指令执行序列为：

```assembly
mov ax,6622H
jmp 1000:3 
mov ax,0000
mov bx,ax
jmp bx 
mov ax,0123H
转到第3步执行
```

### 2.12 代码段

​	对于8086PC机，在编程时，**可以根据需要，将一组内存单元定义为一个段**。我们可以将长度为N（N≤64KB）的一组代码，存在一组地址连续、起始地址为16的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了一个代码段。比如，将：

```assembly
mov ax,0000 (B8 00 00) 
add ax, 0123H (05 23 01)
mov bx, ax (8B D8)
jmp bx (FF E3)
```

​	这段长度为10个字节的指令，存放在123B0H～123B9H的一组内存单元中，我们就可以认为，123B0H～123B9H这段内存是用来存放代码的，是一个代码段，它的段地址为123BH，长度为10个字节。

​	如何使得代码段中的指令被执行呢？将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU只认被CS:IP指向的内存单元中的内容为指令。所以，要让CPU执行我们放在代码段中的指令，必须要将CS:IP指向所定义的代码段中的第一条指令的首地址。对于上面的例子，我们将一段代码存放在123B0H～123B9H内存单元中，将其定义为代码段，如果要让这段代码得到执行，可设CS=123BH、IP=0000H。

### 2.c 小结与检测点

#### 小结

1. 段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址。

2. CS存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS：IP指向的内容当作指令执行。
3. 8086CPU的工作过程：

​	①从CS：IP指向的内存单元读取指令，读取的指令进入指令缓冲器；

​	②IP指向下一条指令；

​	③执行指令。（转到步骤①，重复这个过程。）

4. 8086CPU提供转移指令修改CS、IP的内容。

#### 检测点

下面的3条指令执行后，CPU几次修改IP？都是在什么时候？最后IP中的值是多少？

```assembly
mov ax,bx
sub ax, ax
jmp ax
```

解析：

分析：一共修改了4次。

​	读取mov ax,bx 指令后，第一次修改IP
​	读取sub ax,ax指令后，第二次修改IP
​	读取jmp ax指令后，第三次修改IP
​	执行jmp ax指令时，第四次修改IP，最后IP = ax = 0

### 实验1 查看CPU和内存，用机器指令和汇编指令编程

#### 1. 预备知识：Debug的使用

我们以后所有的实验中，都将用到Debug程序，首先学习一下它的主要用法。

**(1)什么是 Debug?**

​	Debug 是DOS、Windows 都提供的实模式（8086方式）程序的调试工具。使用它，可以查看CPU各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。

**(2)我们用到的Debug 功能**

* 用 Debug 的 R 命令查看、改变CPU寄存器的内容
* 用 Debug 的 D 命令查看内存中的内容
* 用 Debug 的 E 命令改写内存中的内容
* 用 Debug 的 U 命令将内存中的机器指令翻译成汇编指令
* 用 Debug 的 T 命令执行一条机器指令
* 用 Debug 的 A 命令以汇编指令的格式在内存中写入一条机器指令。

**(3)进入Debug**

​	Debug是在 DOS方式下使用的程序。我们在进入Debug前，应先进入到DOS方式。

用以下方式可以进入 DOS。

​	①重新启动计算机，进入DOS方式，此时进入的是实模式的DOS.

​	②在 Windows 中进入 DOS 方式，此时进入的是虚拟 8086 模式的 DOS.

WIN10可以通过【开始菜单】→【运行】→【文本框输入cmd】→进入DOS→在指定目录下打开debug.exe

如果WIN10不自带Dubug.exe文件，也可以使用DOSBox进入Debug模式

​	①打开DOSBox

​	②可以看到默认DOSBox里默认磁盘为z盘

​	③输入`mount c: e:\DOSBox-0.74\`，这是用于挂载本地目录到虚拟C盘的一个命令。具体来说，这个命令的作用是将本地的e:\DOSBox-0.74\目录挂载到DOSBox中的虚拟C盘，使得在DOSBox环境中可以访问该目录。

​	④输入`c:`切换到虚拟C盘

​	⑤输入`debug`命令，进入debug模式

流程优化：

* 找到并选中DOSBox快捷方式，右键【属性】→【快捷方式】→【目标】后面加上`-noconsole`可以在打开DOSBox时不必自动打开Status Windows窗口。

* 自动命令：打开配置文件dosbox-0.74.conf，找到[autoexec]，输入：（这样每次打开会自动执行下面三步命令）

```assembly
mount C: E:\DOS\
c:
debug
```

* 调整窗口分辨率：打开配置文件dosbox-0.74.conf，修改`windowresolution=1280x1024`、`output=opengl`

**(4)用 R 命令查看、改变 CPU 寄存器的内容**

​	我们已经知道了 AX、 BX、CX、 DX. CS、IP 这 6 个寄存器，现在看一下它们之中的内容

![2.13.1 使用R命令查看CPU中各寄存器中的内容](文档插图/2.13.1 使用R命令查看CPU中各寄存器中的内容.png)

<center style="color:#C0C0C0">图2.13.1 使用R命令查看CPU中各寄存器中的内容</center>

​	注意CS和IP的值，CS=073F，IP=0100，也就是说，内存073F：0100处的指令为CPU当前要读取、执行的指令。在所有寄存器的下方，Debug还列出了CS：IP所指向的内存单元处所存放的机器码，并将它翻译为汇编指令。可以看到，CS：IP所指向的内存单元为073F:0100，此处存放的机器码为0000，对应的汇编指令为`ADD [BX +SI],AL`（这条指令的含义我们还不知道，先不必深究）。

​	Debug输出的右下角还有一个信息：“DS:0000=CD”，我们以后会进行说明，这里同样不必深究。

* 用R命令来改变寄存器中的内容

​	若要修改一个寄存器中的值，比如AX中的值，可用R命令后加寄存器名来进行， 输入“`r ax`”后按Enter键，将出现“：”作为输入提示，在后面输入要写入的数据后按 Enter键，即完成了对AX中内容的修改。若想看一下修改的结果，可再用R命令查看， 如图2.13.2所示。

![2.13.2 用R命令修改寄存器AX中的内容](文档插图/2.13.2 用R命令修改寄存器AX中的内容.png)

<center style="color:#C0C0C0">图2.13.2 用R命令修改寄存器AX中的内容</center>

​	除了可以修改通用寄存器AX中的内容外，同样的方法也可以修改CS和IP中的内容，这样可以查看不同位置的汇编代码。

**(5)用Debug的 D 命令查看内存中的内容**

​	用Debug的D命令，可以查看内存中的内容，D命令的格式较多，这里只介绍在本次实验中用到的格式。

​	如果我们想知道内存10000H处的内容，可以用“**d段地址:偏移地址**”的格式来查看，

![2.13.3 用Debug的D命令查看内存中的内容](文档插图/2.13.3 用Debug的D命令查看内存中的内容.png)

<center style="color:#C0C0C0">图2.13.3 用Debug的D命令查看内存中的内容</center>

​	使用“d 段地址:偏移地址”的格式，Debug将列出从指定内存单元开始的 128 个内存单元的内容。图2.13.3中，在使用d 1000：0后，Debug列出了1000:0~1000:7F中的内容。

使用D命令，Debug将输出3部分内容（如图2.13.3所示）。

​	①中间是从指定地址开始的 128 个内存单元的内容，用十六进制的格式输出，每行的输出从16的整数倍的地址开始，最多输出16个单元的内容。从图中，我们可以知道，内存1000:0单元中的内容是00H，内存1000：0～1000:F中的内容都在第一行，内存1000：10～1000：1F中的内容都在第二行。

​	注意在每行的中间有一个“-”，它将每行的输出分为两部分，这样便于查看。比如，要想从图中找出1000：6B单元中内容，可以从1000：60找到行，“-”前面是1000:60～1000:67的8个单元，后面是1000：68～1000:6F的8个单元，这样我们就可以从1000：68单元向后数3个单元，找到1000：6B单元

​	②左边是每行的起始地址。

​	③右边是每个内存单元中的数据对应的**可显示的ASCH码字符**。它没有对应可示的ASCI字符，Debug就用“.”来代替。

​	注意，我们看到的内存中的内容，在不同的计算机中是不一样的，也可能每次用Debug 看到的内容都不相同，因为我们用Debug看到的都是原来就在内存中的内容，这些内容受随时都有可能变化的系统环境的影响。

​	我们使用`d 1000:9`查看1000:9处的内容，Debug输出如图2.13.4所示：

![2.13.4 查看1000 9处内容](文档插图/2.13.4 查看1000 9处内容.png)

<center style="color:#C0C0C0">图2.13.4 查看1000:9处内容</center>

​	Debug从1000:9开始显示，一直到1000:88，一共是128个字节。第一行中的1000:0～1000:8单元中的内容不显示。

* 在一进入Debug后，用D命令`-d`直接查看，将列出 **Debug 预设的地址处的内容**。
* 在使用“d段地址：偏移地址”之后，接着使用D命令`-d`，可**列出后续的内容**

* 也可以指定D命令的查看范围，此时采用“`d 段地址:起始偏移地址 结尾偏移地址`”的格式。比如要看1000:0～1000:9中的内容，可以用“`d 1000:0 9`”实现

如果我们就想查看内存单元10000H中的内容，可以用下面的任何一种方法看到，因为三者都表示了10000H这一物理地址。

```assembly
-d 1000:0 0				/*法一*/
-d 0fff:10 10			/*法二*/
-d 0100:f000 f000		/*法三*/
```

**(6)用Debug的 E 命令改写内存中的内容**

​	可以使用E命令来改写内存中的内容，比如，要将内存1000：0～1000：9单元中的内容分别写为0、1、2、3、4、5、6、7、8、9，可以用“`e 起始地址 数据 数据 数据 ··· ···`”的格式来进行，如图2.13.5所示。

​	先用D命令查看1000:0～1000:f单元的内容，再用E命令修改从1000:0开始的10个单元的内容，最后用D命令查看1000:0～1000:f中内容的变化。

![2.13.5 用E命令修改从1000 0开始的10个单元的内容](文档插图/2.13.5 用E命令修改从1000 0开始的10个单元的内容.png)

<center style="color:#C0C0C0">图2.13.5 用E命令修改从1000:0开始的10个单元的内容</center>

​	也可以采用提问的方式来一个一个地改写内存中的内容，如图2.13.6所示。

![2.13.6 用E命令以提问方式修改4个单元的内容](文档插图/2.13.6 用E命令以提问方式修改4个单元的内容.png)

<center style="color:#C0C0C0">图2.13.6 用E命令以提问方式修改4个单元的内容</center>

​	①输入`e 1000:10`,按`Enter`键。

​	②Debug 显示起始地址1000:0010，和第一单元（即1000:0010单元）的原始内容：00，然后光标停在“.”的后面提示输入想要写入的数据，此时可以有两个选择：其一为输入数据（我们输入的是0），然后**按空格键**，即用输入的数据改写当前的内存单元；其二为不输入数据，直接**按空格键**，则不对当前内存单元进行改写。

​	③当前单元处理完成后（不论是改写或没有改写，只要**按了空格键，就表示处理完成**），Debug将接着显示下一个内存单元的原始内容，并提示进行修改，读者可以用同样的方法处理。

​	④所有希望改写的内存单元改写完毕后，按`Enter`键，E命令操作结束。

​	可以用E命令**向内存中写入字符**，比如，用E命令从内存1000:0开始写入数值1、字符“a”、数值2、字符“b”、数值3、字符“c”，可采用图 2.13.7 中所示的方法进行。

![2.13.7 用E命令输入字符](文档插图/2.13.7 用E命令输入字符.png)

<center style="color:#C0C0C0">图2.13.7 用E命令输入字符</center>

​	从图 2.13.7 中可以看出，Debug对E命令的执行结果是，向1000:0、1000:2、1000:4单元中写入数值1、2、3，向1000：1、10003、1000：5单元中写入字符“a”、“b”、“c”的ASCI码值：61H、62H、63H。

**(7)用 E 命令向内存中写入机器码，用 U 命令查看内存中机器码的含义**

​	类似用 E 命令向内存中写入字符，E命令也可以向内存中写入字符串，比如，用E命令从内存1000:0开始写入:数值1、字符串“a+b”、数值2、字符串“c++”、字符3、字符串“IBM”，如图2.13.8 所示。

​	如何向内存中写入机器码呢？我们知道，机器码也是数据，当然可以用E命令将机器码写入内存。比如我们要从内存1000:0单元开始写入这样一段机器码：

| 机器码 | 对应的汇编指令 |
| ------ | -------------- |
| b80100 | mov ax,0001    |
| b90200 | mov cx,0002    |
| 01c8   | add ax,cx      |

![2.13.8 用E命令输入字符串和机器码](文档插图/2.13.8 用E命令输入字符串和机器码.png)

<center style="color:#C0C0C0">图2.13.8 用E命令输入字符串和机器码</center>

​	可以用 U 命令将从 1000：0 开始的内存单元中的内容翻译为汇编指令，并显示出来，如图 2.13.9 所示。

![2.13.9 用U命令将内存单元中的内容翻译为汇编指令显示](文档插图/2.13.9 用U命令将内存单元中的内容翻译为汇编指令显示.png)

<center style="color:#C0C0C0">图2.13.9 用U命令将内存单元中的内容翻译为汇编指令显示</center>

​	图2.13.8首先用 E 命令向从 1000:0 开始的内存单元中写入了 8 个字节的机器码，（接着用D命令从数据角度查看输入内存中的机器码也可以）然后图2.13.9用 U 命令查看从 1000:0 开始的内存单元中的机器指令和它们所对应的汇编指令。

​	U命令的显示输出分为 3 部分，每一条机器指令的地址、机器指令、机器指令所对应的汇编指令。我们可以看到：

​	1000:0处存放的是写入的机器码b8 01 00所组成的机器指令，对应的汇编指令是`mov ax,1`

​	1000:3处存放的是写入的机器码b9 02 00所组成的机器指令；对应的汇编指令是`mov cx,2`

​	1000:6处存放的是写入的机器码01 c8所组成的机器指令；对应的汇编指令是`add ax,cx`

​	1000:8处存放的是内存中的机器码03 49 42所组成的机器指令；对应的汇编指令是`add cx,[bx+di+42]`

​	由此，我们可以再一次看到**内存中的数据和代码没有任何区别，关键在于如何解释**。

**(8)用 T 命令执行内存中的机器码**

​	使用Debug的T命令可以执行一条或多条指令，简单地使用T命令，可以执行CS:IP指向的指令，如图2.13.10所示。

![2.13.10 使用T命令执行CS IP指向的指令](文档插图/2.13.10 使用T命令执行CS IP指向的指令.png)

<center style="color:#C0C0C0">图2.13.10 使用T命令执行CS:IP指向的指令</center>

​	①首先用 E 命令向1000:0开始的内存单元中写入8个字节的机器码

​	②用 R 命令查看CPU中寄存器的状态，可以看到CS和IP的值为两个随机的数字，指向内存中的CS:IP，若要用 T 命令控制 CPU 执行我们写到 1000:0 的指令，必须先让 CS:IP 指向 1000:0

​	③用 R 命令 `-rcs`和`-rip`修改CS、IP中的内容，使 CS:IP 指向 1000:0。

​	完成上面的步骤后，就可以使用 T 命令来执行我们写入的指令了（此时，CS：IP指向我们的指令所在的内存单元）。执行 T 命令后，CPU执行CS:IP指向的指令，则1000:0处的指令b8 01 00（mov ax,0001）得到执行，指令执行后，Debug显示输出 CPU 中寄存器的状态。

​	注意，指令执行后，AX中的内容被改写为1，IP改变为IP+3（因为mov ax,0001的指令长度为3个字节），CS:IP指向下一条指令。我们可以继续使用T命令执行后面的指令，注意每条指令执行后，CPU相关寄存器内容的变化。

**(9)用Debug的A命令以汇编指令的形式在内存中写入机器指令**

​	前面我们使用E命令写入机器指令，这样做很不方便，最好能**直接以汇编指令的形式写入指令**。为此，Debug提供了A命令。A命令的使用方法如图2.13.11所示。

![2.13.11 用A命令向从目标地址或预设地址开始的内存单元中写入指令](文档插图/2.13.11 用A命令向从目标地址或预设地址开始的内存单元中写入指令.png)

<center style="color:#C0C0C0">图2.13.11 用A命令向从目标地址或预设地址开始的内存单元中写入指令</center>

​	首先用A命令，以汇编语言向从1000:0开始的内存单元中写入了几条指令，然后用D命令查看A命令的执行结果。可以看到，在使用A命令写入指令时，我们输入的是汇编指令，Debug将这些汇编指令翻译为对应的机器指令，将它们的机器码写入内存。

​	使用A命令写入汇编指令时，在给出的起始地址后直接按Enter键表示操作结束。

​	接下来，可以继续简单地用A命令，从一个**预设的地址**开始输入指令。

> **本次实验中需要用到的命令**
>
> * 查看、修改CPU中寄存器的内容：R命令
>
> * 查看内存中的内容：D命令
> * 修改内存中的内容：E命令（可以写入数据、指令，在内存中，它们实际上没有区别）
> * 将内存中的内容解释为机器指令和对应的汇编指令：U命令
> * 执行CS：IP指向的内存单元处的指令：T命令
> * 以汇编指令的形式向内存中写入指令：A命令
>
> ​	在预备知识中，详细讲解了Debug的基本功能和用法。在汇编语言的学习中，Debug是一个经常用到的工具，在学习预备知识中，应该一边看书一边在机器上操作。

#### 2.实验任务

​	(1)使用Debug，将下面的程序段写入内存，逐条执行，观察每条指令执行后CPU中相关寄存器中内容的变化。

| 机器码   | 汇编指令      |
| -------- | ------------- |
| b8 20 4e | mov ax, 4E20H |
| 05 16 14 | add ax, 1416H |
| bb 00 20 | mov bx, 2000H |
| 01 d8    | add ax, bx    |
| 89 c3    | mov bx, ax    |
| 01 d8    | add ax, bx    |
| b8 1a 00 | mov ax, 001AH |
| bb 26 00 | mov bx, 0026H |
| 00 d8    | add al, bl    |
| 00 dc    | add ah, bl    |
| 00 c7    | add bh, al    |
| b4 00    | mov ah, 0     |
| 00 d8    | add al, bl    |
| 04 9c    | add al, 9CH   |

（提示，可用 E 命令和 A 命令以两种方式将指令写入内存。注意用 T 命令执行时， CS:IP的指向。）

![2.13.12 实验任务(1)执行流程](文档插图/2.13.12 实验任务(1)执行流程.png)

<center style="color:#C0C0C0">图2.13.12 实验任务(1)执行流程</center>

(2)将下面 3 条指令写入从 2000:0 开始的内存单元中，利用这 3 条指令计算 2 的 8 次方。

```assembly
mov ax,1
add ax, ax
jmp 2000:0003
```

![2.13.13 实验任务(2)执行流程](文档插图/2.13.13 实验任务(2)执行流程.png)

<center style="color:#C0C0C0">图2.13.13 实验任务(2)执行流程</center>

(3)查看内存中的内容

​	PC机主板上的ROM 中写有一个生产日期，在内存FFF00H~FFFFFH 的某几个单元中，请找到这个生产日期并试图改变它。

解析：无法修改PC机主板上的ROM中的生产日期，因为是只读存储器的内容

![2.13.14 查看内存中的内容](文档插图/2.13.14 查看内存中的内容.png)

<center style="color:#C0C0C0">图2.13.14 查看内存中的内容并修改</center>

(4)向内存从B8100H开始的单元中填写数据，如：

`-е B810:0000 01 01 02 02 03 03 04 04`

请先填写不同的数据，观察产生的现象；再改变填写的地址，观察产生的现象。

解析：

​	从B8100H开始的单元中填写上述数据，屏幕某个位置会产生一个图形，改变填写地址，图形位置会变化，这是因为B8100H开始的单元为显存位置（A0000H~BFFFFH为**显存地址空间**），在该段地址中输入数据后会在显示器上输出相应的内容。

![2.13.15 向内存从B8100H开始的单元中填写数据](文档插图/2.13.15 向内存从B8100H开始的单元中填写数据.png)

<center style="color:#C0C0C0">图2.13.15 向内存从B8100H开始的单元中填写数据</center>

## 第 3 章 寄存器(内存访问)

​	第2章中，我们主要从CPU**如何执行指令的角度**讲解了8086CPU的逻辑结构、形成物理地址的方法、相关的寄存器以及一些指令。这一章中，我们从**访问内存的角度**继续学习几个寄存器。

### 3.1 内存中字的存储

​	CPU中，用16位寄存器来存储一个字。**高8位存放高位字节，低8位存放低位字节**。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。比如我们从0地址开始存放20000(4E20H)，这种情况如图3.1所示。

| 内存单元 | 内容 |
| -------- | ---- |
| 0        | 20H  |
| 1        | 4EH  |
| 2        | 12H  |
| 3        | 00H  |
| 4        |      |
| 5        |      |

<center style="color:#C0C0C0">图3.1 内存中字的存储</center>

​	在图3.1中，我们用0、1两个内存单元存放数据20000（4E20H）。0、1两个内存单元用来存储一个字，这两个单

元可以看作一个起始地址为0的**字单元**（存放一个字的内存单元，由0、1两个字节单元组成）。对于这个字单元来说，0号单元是低地址单元，1号单元是高地址单元，则字型数据4E20H的低位字节存放在0号单元中，高位字节存放在1号单元中。同理，将2、3号单元看作一个字单元，它的起始地址为 2。在这个字单元中存放数据18（0012H），则在2号单元中存放低位字节12H，在3号单元中存放高位字节00H。

​	我们提出字单元的概念：**字单元**，即**存放一个字型数据（16 位）的内存单元**，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。

​	在以后的课程中，我们将起始地址为N的字单元简称为N地址字单元。比如一个字单元由2、3两个内存单元组成，则这个字单元的起始地址为2，我们可以说这是2地址字单元。

#### 问题3.1

对于图3.1：

(1) 0 地址单元中存放的字节型数据是什么。`20H`

(2) 0 地址字单元中存放的字型数据是什么。`4E20H`

(3)2地址单元中存放的字节型数据是多少？`12H`

(4)2地址字单元中存放的字型数据是多少？`0012H`

(5)1地址字单元中存放的字型数据是多少？`124EH`

思考后看分析。

分析：

​	对于(5)，1地址字单元，即起始地址为1的字单元，它由1号单元和2号单元组成，用这两个单元存储一个字型数据，高位放在2号单元中，即12H，低位放在1号单元中，即4EH，它们组成字型数据是124EH，大小为：4686。

​	从上面的问题中我们看到，**任何两个地址连续的内存单元，N号单元和N+1号单元，可以将它们看成两个内存单元，也可看成一个地址为N的字单元中的高位字节单元和低位字节单元**。

### 3.2 DS 和[address]

​	CPU 要读写一个内存单元的时候，必须先给出这个内存单元的地址，在 8086PC 中，内存地址由段地址和偏移地址组成。8086CPU中有一个 DS 寄存器，通常用来**存放要访问数据的段地址**。比如我们要读取 10000H 单元的内容，可以用如下的程序段进行：

```assembly
mov bx,1000H
mov ds,bx
mov al,[0]
```

​	上面的 3 条指令将10000H（1000:0）中的数据读到 al 中。

下面详细说明指令的含义。

```assembly
mov al, [0]
```

​	前面我们使用 mov 指令，可完成两种传送：①将数据直接送入寄存器；②将一个寄存器中的内容送入另一个寄存器。

​	也可以使用 mov 指令将一个内存单元中的内容送入一个寄存器中。从哪一个内存单元送到哪一个寄存器中在指令中必须指明。寄存器用寄存器名来指明，内存单元则需用内存单元的地址来指明。显然，此时 mov 指令的格式应该是：`mov 寄存器名，内存单元地址`。

“[...]”表示一个内存单元， “[...]”中的0表示**内存单元的偏移地址**。指令执行时，8086CPU自动取ds中的数据为内存单元的段地址，和偏移地址两者共同定位一个内存单元。

​	我们先将段地址1000H放入ds，然后用`mov al,[0]`完成传送。mov指令中的`[]`说明操作对象是一个内存单元，`[]`中的0说明这个内存单元的偏移地址是0，它的段地址默认放在ds中，指令执行时，8086CPU会自动从ds中取出。

```assembly
mov bx,1000H 
mov ds,bx
```

​	若要用`mov al,[0]`完成数据从1000:0单元到 al 的传送，这条指令执行时，ds中的内容应为段地址1000H，所以在这条指令之前应该将1000H送入ds。

​	如何把一个数据送入寄存器呢？我们以前用类似“`mov ax,1`”这样的指令来完成，从理论上讲，我们可以用相似的方式：`mov ds,1000H`，来将1000H送入ds。可现实并非如此，**8086CPU不支持将数据直接送入段寄存器的操作**，ds是一个段寄存器，所以`mov ds,1000H`这条指令是非法的。只好先将1000H送入一个一般的寄存器作为中转，如bx，再将bx中的内容送入ds。（由于8086CPU硬件设计的问题，8086CPU不支持将数据直接送入段寄存器）

#### 问题3.2

​	写几条指令，将 al 中的数据送入内存单元10000H中，思考后看分析。

分析：

​	怎样将数据从寄存器送入内存单元？从内存单元到寄存器的格式是：“`mov 寄存器名,内存单元地址`”，从寄存器到内存单元则是：“`mov 内存单元地址,寄存器名`”。10000H可表示为1000:0，用ds存放段地址1000H，偏移地址是0，则`mov [0],al`，可完成从al到10000H的数据传送。完整的几条指令如下：

```assembly
mov bx, 1000H
mov ds, bx;
mov [0], al;
```

### 3.3 字的传送

​	前面我们用mov指令在寄存器和内存之间进行字节型数据的传送。因为8086CPU是16位结构，有16根数据线，所以，可以一次性传送16位的数据，也就是说可以一次性传送一个字。只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了。比如：

```assembly
mov bx,1000H
mov ds,bx 
mov ax,[0]	;1000:0处的字型数据送入ax
mov [0],cx	;cx中的16位数据送到1000：0处
```

#### 问题3.3

内存中的情况如图3.3.1所示，写出下面的 7 条指令执行后寄存器ax, bx, cx 中的值。思考后看分析。

```assembly
mov ax,1000H
mov ds,ax
mov ax,[0]
mov bx,[2]
mov cx,[1]
add bx,[1]
add cx,[2]
```

| 地址   | 值   |
| ------ | ---- |
| 10000H | 23   |
| 10001H | 11   |
| 10002H | 22   |
| 10003H | 66   |

<center style="color:#C0C0C0">图3.3.1 内存情况示意(1)</center>

分析：

<center style="color:#C0C0C0">表3.3.1 指令执行与寄存器中的内容(1)</center>

| 指令         | 执行后相关寄存器中的内容 | 说明                                                         |
| ------------ | ------------------------ | ------------------------------------------------------------ |
| mov ax,1000H | ax=1000H                 | -                                                            |
| mov ds,ax    | ds=1000H                 | 前两条指令的目的是将 ds 设为 1000H                           |
| mov ax,[0]   | ax=1123H                 | 1000:0 处存放的字型数据送入 ax 1000;<br />1000:1 单元存放字型数据的高8位：11H, <br />1000:0 单元存放字型数据的低 8 位：23H, <br />所以 1000:0 处存放的**字型数据**为 1123H。<br />指令执行时，字型数据的高 8 位送入 ah,字型数据的低 8 位送入 al,则 ax 中的数据为 1123H |
| mov bx,[2]   | bx=6622H                 | 原理同上                                                     |
| mov cx,[1]   | cx=2211H                 | 原理同上                                                     |
| add bx,[1]   | bx=8833H                 | 原理同上                                                     |
| add cx,[2]   | cx=8833H                 | 原理同上                                                     |

#### 问题3.4

​	内存中的情况如图3.3.2所示，写出下面的指令执行后内存中的值，思考后看分析。

```assembly
mov ax,1000H
mov ds,ax
mov ax,11316
mov [0],ax
mov bx,[0]
sub bx,[2]
mov [2],bx
```

| 地址   | 值   |
| ------ | ---- |
| 10000H | 23   |
| 10001H | 11   |
| 10002H | 22   |
| 10003H | 11   |

<center style="color:#C0C0C0">图3.3.2 内存情况示意(2)</center>

分析：

​	进行单步跟踪，看一下每条指令执行后相关寄存器或内存单元中的值，见表3.3.2。

<center style="color:#C0C0C0">表3.3.2 指令执行与寄存器中的内容(2)</center>

| 指令         | 执行后相关寄存器中的内容                                     | 说明                                                         |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| mov ax,1000H | ax=1000H                                                     | -                                                            |
| mov ds,ax    | ds=1000H                                                     | 前两条指令的目的是将 ds 设为 1000H                           |
| mov ax,11316 | ax=2C34H                                                     | 十进制11316，二进制10 1100 0011 0100，十六进制2C34H          |
| mov [0],ax   | 10000H 34<br />10001H 2C<br />10002H 22<br />10003H 11<br /> | ax 中的字型数据送到 1000:0 处<br />ax 中的字型数据是 2C34H,<br />高8位：2CH,在ah中<br />低8位：34H,在al中<br />指令执行时，高 8 位送入高地址 1000:1 单元，低 8 位送入低地址 1000:0 单元 |
| mov bx,[0]   | bx=2C34H                                                     | 10000H开始的字单元中的数据送入bx                             |
| sub bx,[2]   | bx=1B12H                                                     | bx=“bx中的字型数据-1000:2 处的字型数据=2C34H-1122H=1B12H”    |
| mov [2],bx   | 10000H 34<br />10001H 2C<br />10002H 12<br />10003H 1B<br /> | bx中的字型数据送到 1000:2 处                                 |

### 3.4 mov、add、sub指令

前面我们用到了mov、add、sub指令，它们都带有两个操作对象。

到现在，我们知道，mov指令可以有以下几种形式。

| 指令 | 形式              | 例子         |
| ---- | ----------------- | ------------ |
| mov  | `寄存器,数据`     | `mov ax,8`   |
| mov  | `寄存器,寄存器`   | `mov ax,bx`  |
| mov  | `寄存器,内存单元` | `mov ax,[0]` |
| mov  | `内存单元,寄存器` | `mov [0],ax` |
| mov  | `段寄存器,寄存器` | `mov ds,ax`  |

​	我们可以根据这些已知指令进行下面的推测。

①既然有“`mov 段寄存器,寄存器`”，从寄存器向段寄存器传送数据，那么也应该有“mov寄存器，段寄存器”，从段寄存器向寄存器传送数据。一个合理的设想是： **8086CPU内部有寄存器到段寄存器的通路，那么也应该有相反的通路**。

​	图3.4.1中，用A命令在一个预设的地址073F:0100处，用汇编的形式`mov ax,ds`写入指令，再用 T 命令执行，可以看到执行的结果，段寄存器 ds 中的值送到了寄存器 ax 中。通过验证我们知道，“`mov 寄存器,段寄存器`”是正确的指令。

![3.4.1 试验mov ax,ds](文档插图/3.4.1 试验mov ax,ds.png)

<center style="color:#C0C0C0">图3.4.1 试验mov ax,ds</center>

②既然有“`mov 内存单元,寄存器`”，从寄存器向内存单元传送数据，那么也应该有“`mov 内存单元,段寄存器`”，从段寄存器向内存单元传送数据。比如我们可以将段寄存器 cs 中的内容送入内存 10000H 处，指令如下。

```assembly
mov ax,1000H
mov ds,ax
mov [0],cs
```

在Debug中进行试验，如图 3.4.2 所示。

![3.4.2 试验mov [0],cs](文档插图/3.4.2 试验mov [0],cs.png)

<center style="color:#C0C0C0">图3.4.2 试验mov [0],cs</center>

​	图3.4.2中，当CS:IP指向073F:0105的时候，Debug显示当前的指令`mov [0000],cs`，因为这是一条访问内存的指令，Debug还显示出指令要访问的内存单元中的内容。由于指令中的**CS是一个16位寄存器，所以要访问（写入)的内存单元是一个字单元**，它的偏移地址为0，段地址在ds中，Debug在屏幕右边显示出“DS:0000=0000”，我们可以知道这个字单元中的内容为0。

​	`mov [0000],cs` 执行后，CS 中的数据(073FH)被写入1000:0处，1000:1单元存放07H，1000:0单元存放3FH。

​	最后，用D命令从1000:0开始查看指令执行后内存中的情况，注意1000:0、1000:1两个单元的内容。

③“`mov 段寄存器,内存单元`”也应该可行，比如我们可以用10000H处存放的字型数据设置ds(即将10000H处存放的字型数据送入ds)，指令如下：

```assembly
mov ax,1000H
mov ds,ax
mov ds,[0]
```

![3.4.3 试验mov ds,[0]](文档插图/3.4.3 试验mov ds,[0].png)

<center style="color:#C0C0C0">图3.4.3 试验mov ds,[0]</center>

add和sub指令同mov一样，都有两个操作对象。它们也可以有以下几种形式：

| 指令 | 格式              | 例子         |
| ---- | ----------------- | ------------ |
| add  | `寄存器,数据`     | `add ax,8`   |
| add  | `寄存器,寄存器`   | `add ax,bx`  |
| add  | `寄存器,内存单元` | `add ax,[0]` |
| add  | `内存单元,寄存器` | `add [0],ax` |
| sub  | `寄存器,数据`     | `sub ax,9`   |
| sub  | `寄存器,寄存器`   | `sub ax,bx`  |
| sub  | `寄存器,内存单元` | `sub ax,[0]` |
| sub  | `内存单元,寄存器` | `sub [0],ax` |

* **add和sub指令不能对段寄存器进行操作**‌。这是由于硬件限制，段寄存器不能参与运算‌。

### 3.5 数据段

​	2.8节讲过，对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为N(N≤64KB) 、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。比如用123B0H～123B9H这段内存空间来存放数据，我们就可以认为，123B0H～123B9H这段内存是一个数据段，它的段地址为123BH，长度为10个字节。

如何访问数据段中的数据呢？将一段内存当作数据段，是我们在编程时的一种安排，可以在具体操作的时候，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。

​	比如，将123B0H~123B9H的内存单元定义为数据段。现在要累加这个数据段中的前3个单元中的数据，代码如下。

```assembly
mov ax,123BH
mov ds,ax		;将123BH送入ds中，作为数据段的段地址
mov al,0		;用al存放累加结果
add al,[0]		;将数据段第一个单元（偏移地址为0）中的数值加到al中
add al,[1]		;将数据段第二个单元（偏移地址为1）中的数值加到al中
add al,[2]		;将数据段第三个单元（偏移地址为2）中的数值加到a1中
```

#### 问题 3.5

​	写几条指令，累加数据段中的前3个**字型数据**，思考后看分析。

​	分析：

```assembly
mov ax,123BH
mov ds,ax		;将123BH送入ds中，作为数据段的段地址
mov ax,0		;用ax存放累加结果
add ax,[0]		;将数据段第一个字（偏移地址为0）加到ax 
add ax,[2]		;将数据段第二个字（偏移地址为2）加到ax中
add ax,[4]		;将数据段第三个字（偏移地址为4）加到ax中
```

​	注意，一个字型数据占两个单元，所以偏移地址是0、2、4。

#### 小结 3.1～3.5

> ①字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中高位字节存放在高地址单元中。
>
> ②用mov指令访问内存单元，可以在mov指令中**只给出单元的偏移地址**，此时，**段地址默认在DS寄存器中**。
>
> ③[address]表示一个偏移地址为address的内存单元。
>
> ④在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。
>
> ⑤mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。
>
> ⑥可以根据自己的推测，在Debug中实验指令的新格式。

### 3.a 检测点

(1)在Debug中，用“d 0:0 lf”查看内存，结果如下。

```assembly
0000:0000 70 80 F0 30 EF 60 30 E2-00 80 80 12 66 20 22 60
0000:0010 62 26 E6 D6 CC 2E 3C 3B-AB BA 00 00 26 06 66 88
```

下面的程序执行前，AX=0，BX=0，写出每条汇编指令执行完后相关寄存器中的值。

| 指令          | 寄存器的值 | 解析                                                         |
| ------------- | ---------- | ------------------------------------------------------------ |
| mov ax,1      | AX=0001H   | 注意ds的设置。                                               |
| mov ds,ax     | DS=0001H   | 注意ds的设置。                                               |
| mov ax,[0000] | AX=`2662H` | 1H×16+0000H=00010H正好对应第二行第一个单元，把该地址起始的字型数据放入AX |
| mov bx,[0001] | BX=`E626H` | 把00011H起始的字传入BX                                       |
| mov ax,bx     | AX=`E626H` | 把BX中的字传入AX                                             |
| mov ax,[0000] | AX=`2662H` | -                                                            |
| mov bx,[0002] | BX=`D6E6H` | 把00012H开始的字传入BX                                       |
| add ax,bx     | AX=`FD48H` | AX=AX+BX                                                     |
| add ax,[0004] | AX=`2C14H` | AX=AX+2ECCH                                                  |
| mov ax,0      | AX=`0000H` | -                                                            |
| mov al,[0002] | AX=`00E6H` | 00012H的低8位传入al                                          |
| mov bx,0      | BX=`0000H` | -                                                            |
| mov bl,[000C] | BX=`0026H` | 0001CH的低八位传入bl，即0626H的低位                          |
| add al,bl     | AX=`000CH` | 注意，低8位寄存器和高8位寄存器都是**独立**的，低位8进位舍去，不会传入高8位 |

(2) 内存中的情况如图3.5所示。
各寄存器的初始值：CS=2000H，IP=0，DS=1000H，AX=0，BX=0；
① 写出CPU执行的指令序列(用汇编指令写出)。 
② 写出CPU执行每条指令后，CS、IP和相关寄存器中的数值。 
③ 再次体会：数据和程序有区别吗？如何确定内存中的信息哪些是数据，哪些是程序？

<table><thead>
  <tr>
    <th>10000H</th>
    <th>10001H</th>
    <th>10002H</th>
    <th>10003H</th>
    <th>10004H</th>
    <th>10005H</th>
    <th>10006H</th>
    <th>10007H</th>
    <th>10008H</th>
    <th>10009H</th>
    <th>1000AH</th>
    <th>... ...</th>
  </tr></thead>
<tbody>
  <tr>
    <td>B8</td>
    <td>00</td>
    <td>20</td>
    <td>8E</td>
    <td>D8</td>
    <td>A1</td>
    <td>08</td>
    <td>00</td>
    <td>A1</td>
    <td>02</td>
    <td>00</td>
    <td>... ...</td>
  </tr>
  <tr>
    <td colspan="3">mov ax,2000H</td>
    <td colspan="2">mov ds,ax</td>
    <td colspan="3">mov ax,[0008]</td>
    <td colspan="3">mov ax,[0002]</td>
    <td>... ...</td>
  </tr>
  <tr>
    <td>20000H</td>
    <td>20001H</td>
    <td>20002H</td>
    <td>20003H</td>
    <td>20004H</td>
    <td>20005H</td>
    <td>20006H</td>
    <td>20007H</td>
    <td>20008H</td>
    <td>20009H</td>
    <td>... ...</td>
    <td>... ...</td>
  </tr>
  <tr>
    <td>B8</td>
    <td>22</td>
    <td>66</td>
    <td>EA</td>
    <td>00</td>
    <td>01</td>
    <td>F0</td>
    <td>0F</td>
    <td>89</td>
    <td>C3</td>
    <td>... ...</td>
    <td>... ...</td>
  </tr>
  <tr>
    <td colspan="3">mov ax,6622H</td>
    <td colspan="5">jmp 0ff0:0100</td>
    <td colspan="2">mov bx,ax</td>
    <td>... ...</td>
    <td>... ...</td>
  </tr>
</tbody></table>

<center style="color:#C0C0C0">图3.5 内存中的情况</center>

解析：

| 指令序列      | CS    | IP    | DS    | AX    | BX    | 说明                                      |
| ------------- | ----- | ----- | ----- | ----- | ----- | ----------------------------------------- |
| 初始状态      | 2000H | 0000H | 1000H | 0000H | 0000H | 初始值                                    |
| mov ax,6622H  | -     | 0003H | -     | 6622H | -     | DS:IP=2000:0000，从20000H读代码，AX=6622H |
| jmp 0ff0:0100 | -     | 0008H | -     | -     | -     | 无条件跳转指令                            |
|               | 0FF0H | 0100H | -     | -     | -     | jmp指令执行完毕后改变CS:IP                |
| mov ax,2000H  | -     | 0103H | -     | 2000H | -     | 0FF0H×16+0100H=10000H，AX=2000H           |
| mov ds,ax     | -     | 0105H | 2000H | -     | -     | DS=2000H                                  |
| mov ax,[0008] | -     | 0108H | -     | C389H | -     | 20008H处的字放入AX                        |
| mov ax,[0002] | -     | 010BH | -     | EA66H | -     | 20002H处的字放入AX                        |
| 结束状态      | 0FF0H | 010BH | 2000H | EA66H | 0000H |                                           |

* 数据和程序在计算机中都以二进制代码存放，没有区别，**CS:IP指向的就当成指令，DS:[addr]指向的就当成数据**。

### 3.6 栈

​	栈是一种具有特殊的访问方式(**LIFO(Last In, First Out)后进先出**)的存储空间。

​	从程序化的角度来讲，有一个标记一直指示着栈顶。

​	栈有两个基本的操作：**入栈和出栈**。入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。

### 3.7 CPU提供的栈机制

​	现今的CPU中都有栈的设计，8086CPU也不例外。8086CPU提供相关的指令来以栈的方式访问内存空间。这意味着，在基于8086CPU编程的时候，**可以将一段内存当作栈来使用**。

​	8086CPU 提供入栈和出栈指令，最基本的两个是 PUSH（入栈）和 POP（出栈）。比如，push ax 表示将寄存器 ax 中的数据送入栈中，pop ax 表示从栈顶取出数据送入 ax。8086CPU的**入栈和出栈操作**都是**以字为单位进行**的。

​	下面举例说明，我们可以将10000H～1000FH这段内存当作栈来使用。下图描述了下面一段指令的执行过程。

![3.7 8086CPU的栈操作](文档插图/3.7 8086CPU的栈操作.png)

<center style="color:#C0C0C0">图3.7 8086CPU的栈操作</center>

```assembly
mov ax,0123H
push ax
mov bx,2266H
push bx
mov cx,1122H
push cx
pop ax
pop bx
pop cx
```

* 字型数据用两个单元存放，高地址单元存放高8位，低地址单元存放低8位。

然而，上述过程会存在两个问题：

1. CPU如何知道10000H～1000FH这段空间被当作栈来使用？
2. push、pop在执行的时候，必须知道哪个单元是栈顶单元，可是，如何知道呢？

​	类比CS、IP中存放着当前指令的段地址和偏移地址。显然，也应该有相应的寄存器来存放栈顶的地址，8086CPU中，有两个寄存器，**栈段寄存器 SS **和**堆栈指针寄存器 SP**，栈顶的段地址存放在SS中，偏移地址存放在SP中。任意时刻，SS:SP指向栈顶元素。push指令和 pop 指令执行时，CPU从SS和SP中得到栈顶的地址。

​	现在，我们可以完整地描述 push 和 pop 指令的功能了，例如push ax。push ax 的执行，由以下两步完成。

1. SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；
2. 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。

下图描述了8086CPU对push指令的执行过程：

![3.7.1 push指令的执行过程](文档插图/3.7.1 push指令的执行过程.png)

<center style="color:#C0C0C0">图3.7.1 push指令的执行过程</center>

​	从图中我们可以看出，8086CPU中，入栈时，**栈顶从高地址向低地址方向增长**。

#### 问题 3.6

如果将10000H～1000FH这段空间当作栈，初始状态栈是空的，此时，SS=1000H，SP=？思考后看分析。

分析：

SP=0010H，如图3.7.2所示：

![3.7.2 栈空的状态](文档插图/3.7.2 栈空的状态.png)

<center style="color:#C0C0C0">图3.7.2 栈空的状态</center>

​	将10000H~1000FH这段空间当作栈段， SS=1000H，栈空间大小为16字节，**栈最底部的字单元地址为1000：000E**。任意时刻， SS:SP指向栈顶，当栈中只有一个元素的时候， SS=1000H， SP=000EH。栈为空，就相当于栈中唯一的元素出栈， 出栈后，SP=SP+2， SP原来为000EH，加2后SP=10H，所以，当栈为空的时候， SS=1000H，SP=10H。

​	换一个角度看，任意时刻，SS:SP 指向栈顶元素，当栈为空的时候，栈中没有元素，也就**不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元**，该单元的偏移地素址为栈最底部的字单元的偏移地址+2，栈最底部字单元的地址为1000：000E，所以栈空时，SP=0010H。

​	接下来，我们描述pop指令的功能，例如pop ax

​	pop ax 的执行过程和 push ax 刚好相反，由以下两步完成。

1. 将 SS:SP 指向的内存单元处的数据送入 ax 中；
2. SP=SP+2， SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

​	下图描述了8086CPU对pop指令的执行过程。

![3.7.3 pop指令的执行过程](文档插图/3.7.3 pop指令的执行过程.png)

<center style="color:#C0C0C0">图3.7.3 pop指令的执行过程</center>

​	注意，图 3.7.3 中，出栈后，SS:SP 指向新的栈顶 1000EH，pop 操作前的栈顶元素，**1000CH处的2266H依然存在，但是，它已不在栈中**。当再次执行push等入栈指令后，SS：SP 移至 1000CH，并在里面写入新的数据，它将被覆盖。

### 3.8 栈顶超界的问题

​	8086CPU用SS和SP指示栈顶的地址，并提供push和pop指令实现入栈和出栈。

​	但是，还有一个问题需要讨论，就是SS和SP只是记录了栈顶的地址，依靠SS和SP可以保证在入栈和出栈时找到栈顶。可是，如何能够保证在入栈、出栈时，栈顶不会超出栈空间？

​	图3.8描述了在执行push指令后，栈顶超出栈空间的情况。

​	图3.8中，将10010H～1001FH当作栈空间，该栈空间容量为16字节（8字），初始状态为空，SS=1000H、SP=0020H,SS:SP指向10020H;

​	在执行8次push ax后，向栈中压入8个字，栈满，SS:SP指向10010H；

​	再次执行 push ax: sp=sp-2，SS:SP 指向 1000EH，栈顶超出了栈空间，ax中的数据送入1000EH单元处，将栈空间外的数据覆盖。

​	图3.8描述了在执行pop指令后，栈顶超出栈空间的情况。

​	图3.8中，将10010H～1001FH当作栈空间，该栈空间容量为16字节（8字），当前状态为满，SS=1000H、SP=0010H,SS:SP指向10010H;

![3.8 执行push或pop后栈顶超出栈空间](文档插图/3.8 执行push或pop后栈顶超出栈空间.png)

<center style="color:#C0C0C0">图3.8 执行push或pop后栈顶超出栈空间</center>

​	在执行8次pop ax后，从栈中弹出8个字，栈空，SS：SP指向10020H；

​	再次执行 pop ax: sp=sp+2，SS:SP指向10022H，栈顶超出了栈空间。此后，如果再执行push指令，10020H、10021H中的数据将被覆盖。

​	上面描述了执行 push、pop 指令时，发生的栈顶超界问题。可以看到，当**栈满的时候再使用push指令入栈，或栈空的时候再使用pop指令出栈，都将发生栈顶超界问题**。

​	栈顶超界是危险的，因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己程序中的，也可能是别的程序中的（毕竟一个计算机系统中并不是只有我们自己的程序在运行）。但是由于我们在入栈出栈时的不小心，而将这些数据、代码意外地改写，将会引发一连串的错误。

​	我们当然希望CPU可以帮我们解决这个问题，比如说在CPU中有记录栈顶上限和栈底的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围，然后，CPU在执行push指令的时候靠检测栈顶上限寄存器、在执行pop指令的时候靠检测栈底寄存器保证不会超界。

​	不过，对于8086CPU，这只是我们的一个设想（我们当然可以这样设想，如果CPU是我们设计的话，这也就不仅仅是一个设想）。实际的情况是，8086CPU中并没有这样的寄存器。

​	**8086CPU不保证我们对栈的操作不会超界**。这也就是说，8086CPU只知道栈顶在何处（由SS:SP指示），而不知道我们安排的栈空间有多大。这点就好像CPU只知道当前要执行的指令在何处（由CS:IP指示），而不知道要执行的指令有多少。从这两点上我们可以看出8086CPU的工作机理，它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。

​	我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界；执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。

### 3.9 push、pop 指令

​	前面我们一直在使用 push ax 和 pop ax，显然push 和 pop 指令是可以在寄存器和内存（栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。）之间传送数据的。

​	push 和pop 指令的格式可以是如下形式：

```assembly
push register	;将一个寄存器中的数据入栈
pop register	;出栈，用一个寄存器接收出栈的数据
```

当然也可以是如下形式：

```assembly
push 段寄存器 	;将一个段寄存器中的数据入栈
pop 段寄存器 	;出栈，用一个段寄存器接收出栈的数据
```

push和pop也可以在内存单元和内存单元之间传送数据，我们可以：
```assembly
push 内存单元	;将一个内存字单元处的字入栈（注意：栈操作都是以字为单位）
pop 内存单元	;出栈，用一个内存字单元接收出栈的数据
```

比如：
```assembly
mov ax,1000H
mov ds,ax	;内存单元的段地址要放在ds中
push [0]	;将1000:0处的字压入栈中
pop [2]		;出栈，出栈的数据送入1000:2处
```

指令执行时，CPU要知道内存单元的地址，可以在push、pop指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU从 ds 中取得。

#### 问题3.7

​	编程，将10000H~1000FH这段空间当作栈，初始状态栈是空的，将AX、BX、DS
中的数据入栈。
分析：
代码如下。

```assembly
mov ax,1000H
mov ss,ax		;设置栈的段地址，SS=1000H，不能直接向段寄存器SS中送入数据，所以用ax中转。
mov sp,0010H	;设置栈顶的偏移地址，因栈为空，所以sp=0010H。（详见问题 3.6）
				;注意，不能直接设置ss的偏移地址，但是可以直接设置sp的偏移地址
				;上面的3条指令设置栈顶地址。编程中要自己注意栈的大小。
push ax
push bx
push ds
```

#### 问题3.8

编程：
	①将10000H~1000FH这段空间当作栈，初始状态栈是空的；
	②设置AX=001AH，BX=001BH；
	③将AX、BX中的数据入栈；

​	④然后将AX、BX清零；

​	⑤从栈中恢复AX、BX原来的内容。

解析：

```assembly
mov ax, 1000H
mov ss, ax
mov sp, 0010H	;初始化栈顶，栈的情况如图3.9(a) 所示

mov ax, 001AH
mov bx, 001BH	;ax、bx入栈，栈的情况如图3.9(b) 所示

push ax
push bx

sub ax, ax		;将ax清零，也可以用mov ax，0，
				;sub ax，ax的机器码为2个字节，
				;mov ax，0的机器码为3个字节。
sub bx, bx

pop bx			;从栈中恢复ax、bx原来的数据，当前栈顶的内容是bx中原来的内容：001BH，
				;ax中原来的内容001AH在栈顶的下面，所以要先pop bx，然后再pop ax。
pop ax
```

![3.9 栈的情况示意](文档插图/3.9 栈的情况示意.png)

<center style="color:#C0C0C0">图3.9 栈的情况示意</center>

​	从上面的程序我们看到，用栈来暂存以后需要恢复的寄存器中的内容时，出栈的顺序要和入栈的顺序相反，因为最后入栈的寄存器的内容在栈顶，所以在恢复时，要最先出栈。

#### 问题3.9

编程：

​	①将10000H～1000FH这段空间当作栈，初始状态栈是空的；

​	②设置AX=001AH，BX=001BH;

​	③利用栈，交换AX和BX中的数据。

分析：

```assembly
mov ax, 1000H
mov ss, ax
mov sp, 0010H	;初始化栈顶，栈的情况如图3.9.1(a)所示

mov ax, 001AH
mov bx, 001BH	

push ax
push bx			;ax、bx入栈，栈的情况如图3.9.1(b)所示

pop ax			;当前栈顶的数据是bx中原来的数据：001BH，所以先pop ax,ax=001BH
pop bx			;执行pop ax后，栈顶的数据为ax原来的数据，所以再pop bx,bx=001AH
```

![3.9.1 栈的情况示意](文档插图/3.9.1 栈的情况示意.png)

<center style="color:#C0C0C0">图3.9.1 栈的情况示意</center>

#### 问题3.10

​	如果要在10000H处写入字型数据2266H，可以用以下的代码完成：

```assembly
mov ax,1000H
mov ds,ax 
mov ax, 2266H 
mov [0], ax
```

​	补全下面的代码，使它能够完成同样的功能：在10000H处写入字型数据2266H。

要求：不能使用“`mov 内存单元，寄存器`”这类指令，思考后看分析。

```assembly
______________
______________
______________
mov ax, 2266H 
push ax  
```

分析：

​	我们来看需补全代码的最后两条指令，将 ax 中的 2266H 压入栈中，也就是说，最终应由push ax 将2266H写入10000H处。问题的关键就在于：如何使push ax访问的内存单元是10000H。

​	push ax 是入栈指令，它将在栈顶之上压入新的数据。一定要注意：它的执行过程是，先将记录栈顶偏移地址的SP寄存器中的内容减2，使得SS：SP指向新的栈顶单元，然后再将寄存器中的数据送入SS：SP指向的新的栈顶单元。

​	所以，要在执行 push ax之前，将SS：SP指向 10002H（可以设SS=1000H，SP=0002H),这样，在执行 push ax 的时候，CPU 先将 SP=SP-2,使得 SS:SP 指向 10000H，再将ax中的数据送入SS：SP指向的内存单元处，即10000H处。

​	所以完成的程序如下：

```assembly
mov ax, 1000H
mov ss, ax
mov sp, 0002H
mov ax, 2266H 
push ax  
```

​	从问题3.10的分析中可以看出，push、pop实质上就是一种**内存传送指令**，**可以在寄存器和内存之间传送数据**，与mov指令不同的是，**push和pop 指令访问的内存单元的地址**不是在指令中给出的，而**是由SS:SP指出的**。同时，**push和pop指令还要改变SP中的内容**。

​	我们要十分清楚的是，push和pop指令同 mov 指令不同，CPU执行mov指令只需一步操作，就是传送，而执行 push、pop指令却需要两步操作。

* 执行 **push** 时，CPU的两步操作是：**先改变SP，后向SS:SP处传送**。
* 执行 **pop** 时，CPU的两步操作是：**先读取SS:SP处的数据，后改变SP**。

​	注意，push，pop 等栈操作指令，修改的只是SP。也就是说，栈顶的变化范围最大为：0~FFFFH。

​	提供：SS、SP指示栈顶；改变SP后写内存的入栈指令；读内存后改变SP的出栈指令。这就是8086CPU提供的栈操作机制。

#### 栈的综述 

栈是一种非常重要的机制，一定要深入理解，灵活掌握：

> (1)8086CPU提供了栈操作机制，方案如下。
>
> ​	在SS、SP中存放栈顶的段地址和偏移地址；
>
> ​	提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元。
>
> (2)push指令的执行步骤：①SP=SP - 2；②向SS:SP指向的字单元中送入数据。
>
> (3)pop指令的执行步骤：①从SS:SP指向的字单元中读取数据；②SP=SP + 2。
>
> (4)任意时刻，SS:SP指向栈顶元素。
>
> (5)8086CPU只记录栈顶，栈空间的大小我们要自己管理。
>
> (6)用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。
>
> (7)push、pop实质上是一种内存传送指令，注意它们的灵活应用。

### 3.10 栈段

​	2.8节讲过，对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N（N≤64KB）的一组地址连续、起始地址为 16 的倍数的内存单元，当作栈空间来用，从而定义了一个**栈段**。比如，我们将 10010H~1001FH这段长度为 16 字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为一个栈段，段地址为 1001H，大小为 16 字节。

​	将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排自动地将我们定义的栈段当作栈空间来访问，要在执行 push、pop 等栈操作指令时通过 SS:SP 指向我们定义的栈段。

#### 问题3.11

​	如果将 10000H~1FFFFH 这段空间当作栈段，初始状态栈是空的，此时，SS=1000H， SP=？

解析：

​	如果将 10000H~1FFFFH 这段空间当作栈段，SS=1000H，栈空间为 64KB，栈最底部的字单元地址为 1000:FFFE。任意时刻，SS:SP 指向栈顶单元，当栈中只有一个元素的时候， SS=1000H， SP=FFFEH。栈为空，就相当于栈中唯一的元素出栈，出栈后，SP=SP+2。

​	SP 原来为 FFFEH，加 2 后 SP=0，所以，当栈为空的时候，SS=1000H，SP=0。

​	换一个角度看，任意时刻，SS:SP 指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的地址为栈最底部的字单元的地址+2。栈最底部字单元的地址为1000:FFFE，所以栈空时，SP=0000H

#### 问题3.12

​	一个栈段最大可以设为多少？为什么？思考后看分析。

分析：

​	这个问题显而易见，提出来只是为了提示我们将相关的知识融会起来。首先从栈操作指令所完成的功能的角度上来看，push、pop 等指令在执行的时候只修改SP，所以栈顶的变化范围是0～FFFFH，从栈空时候的SP=0，一直压栈，直到栈满时SP=0；如果再次压栈，栈顶将环绕，覆盖了原来栈中的内容。所以一个栈段的容量最大为64KB。

#### 段的综述

> ​	我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。
>
> ​	我们可以用一个段存放数据，将它定义为“数据段”
>
> ​	我们可以用一个段存放代码，将它定义为“代码段”
>
> ​	我们可以用一个段当作栈，将它定义为“栈段”
>
> 我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：
>
> ​	对于数据段，将它的段地址放在 DS 中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问
>
> ​	对于代码段，将它的段地址放在 CS 中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令；
>
> ​	对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当作栈空间来用。
>
> ​	可见，不管我们如何安排，CPU将内存中的某段内容当作代码，是因CS:IP指向了那里；CPU将某段内存当作栈，是因为SS:SP指向了那里。我们一定要清楚，什么是我们的安排，以及如何让CPU按我们的安排行事。要非常清楚CPU的工作机理，才能在控制CPU按照我们的安排运行的时候做到游刃有余。
>
> ​	比如我们将10000H～1001FH安排为代码段，并在里面存储如下代码：
>
> ```assembly
> mov ax, 1000H
> mov ss, ax mov 
> sp, 0020H		;初始化栈顶 mov ax, cs
> mov ds, ax		;设置数据段段地址 
> mov ax, [0]
> add ax, [2]
> mov bx, [4]
> add bx, [6]
> push ax
> push bx
> pop ax
> pop bx
> 
> ```
>
> ​	设置CS=1000H，IP=0，这段代码将得到执行。可以看到，在这段代码中，我们又将10000H～1001FH安排为栈段和数据段。10000H～1001FH这段内存，既是代码段，又是栈段和数据段。
>
> ​	一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于CPU中寄存器的设置，即CS、IP，SS、SP，DS的指向。

### 检测点 3.b

(1)补全下面的程序，使其可以将 10000H～1000FH 中的8个字，逆序复制到20000H～2000FH中。逆序复制的含义如图3.10所示（图中内存里的数据均为假设）。

![3.10 逆序复制示意图](文档插图/3.10 逆序复制示意图.png)

<center style="color:#C0C0C0">图3.10 逆序复制示意图</center>

```assembly
mov ax, 1000H
mov ds, ax 
_____________
_____________
_____________
push [0]
push [2]
push [4]
push [6]
push [8]
push [A]
push [C]
push [E] 
```

解析：

```assembly
mov ax, 2000H
mov ss, ax;
mov sp, 0010H
```

​	10000H～1000FH内存空间当**数据**来访问，20000H～2000FH内存空间当**栈**来使用。栈空时，栈顶指针应该指向20010H，入栈时，先SP=SP-2=000EH，再入栈，正好是逆序复制目标位置第一个字的地址。

​	（注：`push [0]`指的是把`ds:0`内存单元的数据压入栈）

(2)补全下面的程序，使其可以将10000H～1000FH中的8个字，逆序复制到20000H~2000FH中

```assembly
mov ax, 2000H
mov ds, ax 
_____________
_____________
_____________
pop [E] 
pop [C] 
pop [A] 
pop [8] 
pop [6] 
pop [4] 
pop [2] 
pop [0] 
```

解答：

```assembly
	mov ax, 1000H
	mov ss, ax
	mov sp, 0
```

​	第二小题和第一小题正好相反，将左侧10000H～1000FH当作栈区，右侧当作数据区。

​	栈满时，栈顶指针应指向10000H，出栈时先出栈，再SP=SP + 2，实现逆序复制。

​	（注：`pop [E]`指的是把`ds:E`内存单元的数据弹出栈）

### 实验2 用机器指令和汇编指令编程

#### 1.预备知识：Debug的使用

前面实验中，讲了Debug一些主要命令的用法，这里，再补充一些关于Debug的知识。

**(1)关于D命令**

​	从上次实验中，我们知道，D 命令是查看内存单元的命令，可以用“`d 段地址:偏移地址`”的格式查看指定的内存单元的内容，上次实验中，D命令后面的段地址和偏移地址都是直接给出的。

​	现在，我们知道段地址是放在段寄存器中的，在D命令后面直接给出段地址，是Debug 提供的一种直观的操作方式。D命令是由 Debug 执行的，Debug 在执行“d 1000:0”这样的命令时，也会先将段地址1000H送入段寄存器中。

​	Debug 是利用 CPU 运行一段程序来执行 D 命令的，CPU在访问内存单元的时候从**段寄存器**得到内存单元的段地址。

​	所以，Debug在其处理D命令的程序段中，必须有将段地址送入段寄存器的代码。段寄存器有4个：CS、DS、SS、ES，将段地址送入哪个段寄存器呢？

​	首先不能是CS，因为CS:IP必须指向Debug处理D命令的代码，也不能是SS，因为SS:SP 要指向栈顶。这样只剩下了DS和ES可以选择，放在哪里呢？我们知道，访问内存的指令如“mov ax，[0]”等一般都默认段地址在ds中，所以Debug在执行如“`d 段地址:偏移地址`”这种 **D 命令时，将段地址送入 ds 中比较方便**。

​	D 命令也提供了一种符合CPU机理的格式：“`d 段寄存器:偏移地址`”，以段寄存器中的数据为段地址 SA，列出从SA:偏移地址开始的内存区间中的数据。以下是几个例子。

```assembly
①-r ds
  :1000 
  -d ds:0		 ;查看从1000:0开始的内存区间中的内容
②-r ds
  :1000 
  -d ds:10 18	 ;查看1000:10～1000:18中的内容
③-d cs:0		;查看当前代码段中的指令代码
④-d ss:0		;查看当前栈段中的内容
```

**(2)在E、 A、 U命令中使用段寄存器**

在E、A、U这些可以带有内存单元地址的命令中，也可以同D命令一样，用段寄存

器表示内存单元的段地址，以下是几个例子。

```assembly
① -r ds
  :1000
  -e ds:0 11 22 33 44 55 66 ;在从1000：0开始的内存区间中写入数据
② -u cs:0		;以汇编指令的形式，显示当前代码段中的代码，0代码的偏移地址
③ -r ds
   :1000
   -a ds:0		;以汇编指令的形式，向从1000：0开始的内存单元中写入指令
```

**(3)下一条指令执行了吗？**

在Debug中，用A命令写一段程序：

```assembly
mov ax, 2000
mov ss, ax
mov sp,10	;安排2000:0000～2000:000F为栈空间，初始化栈顶

mov ax, 3123
push ax
mov ax, 3366
push ax		;在栈中压入两个数据
```

​	注意图3.10.1中单步执行的结果：

![3.10.1 mov sp 10哪去了](文档插图/3.10.1 mov sp 10哪去了.png)

<center style="color:#C0C0C0">图3.10.1 mov sp,10哪去了</center>

​	在用T命令单步执行`mov ax,2000`后，显示出当前CPU各个寄存器的状态和下一步要执行的指令：`mov ss,ax`

​	在用T命令单步执行`mov ss,ax`后，显示出当前CPU各个寄存器的状态和下一步要执行的指令···，在这里我们发现了一个问题：`mov ss,ax`的下一条指令应该是`mov sp,10`，怎么变成了 `mov ax,3123`？

​	`mov sp,10`到哪里去了？它被执行了吗？

​	我们再仔细观察，发现：

​	在程序执行前，ax=0000，ss=073f，sp=00fd

​	在用T命令单步执行`mov ax,2000`后，ax=2000；ss=073f；sp=00fd

​	在用T命令单步执行`mov ss,ax`后，ax=2000；ss=2000；sp=0010

​	注意，在用T命令单步执行`mov ss,ax`前，ss=073f，sp=00fd,而执行后 ss=2000, sp=0010。ss 变为2000是正常的，这正是mov ss，ax的执行结果。而在这期间，能够将 sp 设为0010的只有指令`mov sp,10`，看来，`mov sp,10`一定是得到了执行。显然，在用T命令执行`mov ss,ax`的时候，它的下一条指令`mov sp,10`也紧接着执行了。

​	整理一下我们分析的结果：在用T命令执行 `mov ss,ax`的时候，它的下一条指令`mov sp,10`也紧接着执行了。一般情况下，用 T 命令执行一条指令后，会停止继续执行，显示出当前CPU各个寄存器的状态和下一步要执行的指令，但 T 命令执行`mov ss,ax`的时候，没有做到这一点。

​	不单是`mov ss,ax`，对于如`mov ss,bx`，`mov ss,[0]`，` pop ss` 等指令都会发生上面的情况，它们的共性是：**都是修改栈段寄存器SS的指令**。

​	这涉及我们在以后的课程中要深入研究的内容：**中断机制**，它是我们后半部分课程中的一个主题。现在我们只要知道这一点就可以了：**Debug 的 T命令在执行修改寄存器 SS 的指令时，下一条指令也紧接着被执行**。

#### 2.实验任务

(1)使用Debug，将下面的程序段写入内存，逐条执行，根据指令执行后的实际运行情况填空。

```assembly
mov ax,ffff
mov ds,ax 

mov ax,2200
mov ss,ax

mov sp,0100 

mov ax,[0] 	;ax=__C0EAH__
add ax,[2] 	;ax=__C0FCH__
mov bx,[4] 	;bx=__30F0H__
add bx,[6] 	;bx=__6021H__

push ax		;sp=__00FEH__;修改的内存单元的地址是__220FEH__内容为__C0FCH__
push bx		;sp=__00FCH__;修改的内存单元的地址是__220FCH__内容为__6021H__
pop ax		;sp=__00FEH__;ax=__6021H__
pop bx		;sp=__0100H__;bx=__C0FCH__

push [4]	;sp=__00FEH__;修改的内存单元的地址是__220FEH__内容为__30F0H__
push [6]	;sp=__00FCH__;修改的内存单元的地址是__220FCH__内容为__2F31H__
```

![3.10.2 指令运行情况](文档插图/3.10.2 指令运行情况.png)

<center style="color:#C0C0C0">图3.10.2 指令运行情况</center>

(2)仔细观察图3.10.3中的实验过程，然后分析：为什么2000:0～2000:f中的内容会发生改变？

​	可能要再做些实验才能发现其中的规律。如果你在这里就正确回答了这个问题，那么要恭喜你，因为你有很好的悟性。大多数的学习者对这个问题还是比较迷惑的，不过不要紧，因为随着课程的进行，这个问题的答案将逐渐变得显而易见。

![3.10.3 用Debug进行的实验](文档插图/3.10.3 用Debug进行的实验.png)

<center style="color:#C0C0C0">图3.10.3 用Debug进行的实验</center>

分析：

​	观察3.10.3图，我们在2000H内存段创建了一个16 Byte的栈结构，栈空，ss:sp 指向了栈顶2000:10H，给ax赋值后压栈。

​	 初始没有执行这段代码时，我们使用d命令观察2000:00内存，都是00，怎么创建栈结构指向这段内存时，我们发现有些数据了。这些数据是什么？

​	我们发现这里面有CS值-073F、IP值-0108、AX值-2000，还有BP值-0000，还有标志寄存器FLAG值-01A3H。

​	为什么，在讲内中断这章时，你就明白了。T命令实际是引发了单步中断（“跳过”了 `mov sp,10`），执行中断例程时，CPU会将一些**中断例程使用的的寄存器变量自动压栈到栈中，此例中就包括了上述的寄存器变量的值**。（下面②④⑤步骤）

> **中断过程**
> 8086CPU在收到中断信息后，所引发的中断过程。
> ①(从中断信息中)取得中断类型码；
> ②标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)；
> ③设置标志寄存器的第8位TF和第9位IF的值为0(这一步的目的后面将介绍)；
> ④CS的内容入栈；
> ⑤IP的内容入栈；
> ⑥从内存地址为中断类型码4和中断类型码4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。



