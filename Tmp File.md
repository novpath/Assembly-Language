## 第 18 章 综合研究

​	按本书的要求完成了前面所有学习内容的学习者，如果有兴趣用汇编语言对一些相关问题进行一下深入的研究，可以学习本部分内容。

在这部分内容中，本书将启示我们如何进行独立研究和深度思考。同时使我们：

​	(1) 认识到汇编语言对于深入理解其他领域知识的重要性。

​	(2) 对前面所学习的汇编语言知识进行融会。

​	(3) 对用研究的方法进行学习进行体验。

下面看一下我们要研究的问题。

(1) 人们用 C 语言编程时都要用到变量。

比如，程序：打印从“a”到“h”的 8 个字符。

```c
main(){
	int n,ch;
	ch='a';
	for(n=0;n<8;n++)
	{
        printf("%c\n",ch+n);
	}
}
```

(2) C 语言规定，用户写的 C 语言程序都要从 main 函数开始运行，因此 main 函数又称为主函数。

(3) printf 函数可以接收的参数数量不定，我们对此司空见惯，比如：

```c
main()
{
	printf("hello world!");
	printf("%d + %d = %d",1,2,1+2);
}
```

​	注意，上面提到了几个关键词：都要用、规定、司空见惯，在看下面的内容的时候再仔细阅读上面的文字，找到这几个关键词。

思考下面几个问题：

​	(1) 人们用 C 语言编程时都要用变量，我们就非用不可吗？

​	(2) C 语言规定用户写的程序从 main 函数开始，我们就非要用 main 函数吗？

​	(3) printf 函数可以接收不定数量的参数司空见惯，我们就不怀疑了吗？

我们把问题再精简一下，使其变得更本质：

​	(1) 都在用，我们就非得用吗？

​	(2) 规定了，我们就只知道遵守吗？

​	(3) 司空见惯，我们就不怀疑了吗？

​	在很多领域，我们被这些所谓都在用的，规定了的，司空见惯的，蒙蔽了多久呢？如果我们被这些蒙蔽，那么，真正蒙蔽我们的是这些，还是我们自己？

现在我们要研究的 3 个问题：

​	(1) 用 C 语言编程可以不用变量吗？

​	(2) 用 C 语言编程可以不用 main 函数吗？

​	(3) 我们能写一个 printf 函数吗？

注意:

​	(1) 我们使用 TC 2.0 编译器来进行研究，因为这是国内大多数学习者都会使用的 C 语言编译器。

​	(2) 我们的研究所用的基础知识大都是在前面汇编语言的课程中学过的。只有极少数知识是我们前面的课程中没有讲解的，但有前面汇编语言的基础，这些知识学习者都可以通过自己学习和研究掌握。

​	(3) 这部分内容主要是启发学习者进行独立研究和深度思考，一定要注意这一点，相应地调整自己的学习思想。

### 研究试验 1 搭建一个精简的 C 语言开发环境

​	我们要对 C 语言进行深入的研究，就必须从准备一个清晰的 C 语言开发环境开始。

​	我们看下 TC 2.0 的安装目录，有很多的文件和目录，子目录下面还有很多程序和文件。这些程序和文件是我们现在需要在一起，这些程序和文件会对我们研究的问题造成影响吗？问题是，这么多程序和文件都混合在一起，如果其中有某些程序或文件对我们研究的问题有影响，那么，我们容易判断出影响来自哪些程序和文件吗？

​	为了研究的过程清晰明了，我们的原则是：

​	(1) 我们只运行解决当前问题所需要的，我们已知的程序；

​	(2) 所有我们已经知道的程序在解决问题的运行过程中，中需要用到的程序和文件，也都是已知的。

​	这样我们就可以清晰地知道，哪些程序和文件是用干解决那些问题的。

​	这个原则决定了，我们在研究实践中，需要一步步地把我们已知的程序和文件与其他的程序和文件分离开来。

​	按照上面的原则，请完成以下试验。

(1) 在 d 盘建立一个目录(在 Windows 中称为文件夹)tc2.0。在 DOS 环境中，方法如下:

```assembly
d:\md tc2.0
```

​	然后将 tc2.0 的所有文件都拷贝到 d:\tc2.0 目录下。

(2) 在 c 盘建立一个目录 minic。在 DOS 环境中，方法如下:

```assembly
c:\md minic
```

​	这个目录用来存放我们已知的解决问题要用的程序和文件。

​	注意，一般的产品软件系统，都可以通过设置搜索路径的方式让系统提供的程序可以在相关文件不在相同目录的情况下，也可以找到相关的文件。这个做法可能会导致类似以下的情形:

​	我们在把一个程序拷贝到一个空的目录后，这个目录下只有这一个程序，然后我们运行它，它可以正确运行，我们就认为这个程序运行过程中不需要别的文件。但是很可能它在运行过程中使用了别的文件，它不是在当前目录下，而是通过系统设置的搜索路径找到的相关文件。

​	如上情况的会出现会影响我们对一个程序运行过程中使用哪些文件的掌握，而对一些问题产生错误的判断。

我们可以用两种方法解决这个问题:

​	① 不让设置的默认路径指向包含相关文件的目录;

​	② 把我们所要研究的系统的所有文件都拷贝到一个**不可能是系统设置的搜索路径的目录**中。

​	我们上面用的第二种方法，将 tc2.0 的所有文件，都拷贝到 d:\tc2.0 目录下，因为这个目录基本上不可能被 tc2.0 设置成相关文件的搜索路径。这样我们从这个目录拷贝到其他目录(比如 c:\minic)的程序，在运行过程中如果需要使用 tc2.0 中的相关文件，就会出现文件找不到的错误，我们根据提示信息，就可以知道找不到的是哪个文件，也就可能分析出这个文件是什么作用的。

(3) 把我们(国内大多数学习者都)已知的 tc.exe(集成开发环境) 拷贝到 c:\minic 下:

```assembly
c:\minic\copy d:\tc2.0\tc.exe
```

(4) 运行 tc.exe:

```assembly
c:\minic\tc
```

​	用 tc 环境中的菜单项“Options”中的“Directories”选项，对 tc 的工作路径进行设置，将所有路径都清空，即都设置为当前路径。然后用“Save options”选项保存设置。

(5) 在 tc.exe 环境中编辑程序 simple.c，保存到 c:\minic 下。程序 simple.c：

```c
main(){
	printf("hello world!\n");
}
```

(6) 用 tc 环境中菜单项“Compile”中的“Compile to OBJ”，对程序 simple.c 进行编译。看看显示出的提示信息，编译成功了吗？用菜单单项“File”中“Quit”(或按 Alt-X)退出 tc 环境，在 c:\minic 下查找 simple.obj。

(7) 用如下的方法运行 tc.exe:

```assembly
c:\minic\tc simple
```

​	因为 simple.obj 文件已经生成，所以我们用 tc 环境中菜单单项“Compile”中的“Link EXE file”，将 simple.obj 连接为 simple.exe。

​	进行连接后，Message 窗口显示出提示信息：“Unable to open input file 'COS.OBJ'”。

​	看看显示出的提示信息，连接成功了吗？在 c:\minic 下查找 simple.exe，能找到吗？

(8) 可看出，tc 进行连接要使用相关文件，但是找不到，所以出错。

​	为解决这个问题，需要从 d:\tc2.0 目录和子目录下查找到相关文件，将其拷贝到 c:\minic 下。

​	当然，也可以用 tc 环境中的 Options 菜单项下的相关功能设置相关文件(如 .obj 文件)所在的目录的方法，解决找不到 .obj 文件和 .lib 文件的问题，但是，为了让学习者能够对此时需要哪些文件，以及这些文件在什么目录下，如何找到这些文件等问题有清晰的感性认识，这里我们不用这样的方法。

​	如果在 TC 2.0 安装目录下和各个子目录下都找不到所需的.obj 文件和.lib 文件，则需要重新安装一套完整的 TC 2.0。

​	想办法把所有 tc.exe 对程序 simple.obj 进行连接生成 .exe 文件必须用到的相关文件都找到，拷贝到 c:\minic。注意，找的是必须用到的。

(9) 用 c:\minic\tc.exe 对 simple.c 进行编译，连接，生成 simple.exe。

### 研究试验 2 使用寄存器

​	我们用什么，不用什么，都要看我们要解决什么问题。搞清楚问题，就知道了我们的需要，然后我们就不会拘泥于一种方法，因为可能有很多方法都可以解决我们要解决的问题。

​	我们为什么必须用变量？因为在编程时我们必须存储数据。那么如果可以用别的方法存储数据，我们就可以不必因此目的而使用变量。

​	用什么方法来存储数据呢？在学习汇编语言时，我们知道如何存储数据？我们把数据存储在寄存器和内存空间中。

​	那么，在 C 语言中如何使用寄存器和内存空间呢？

​	在本次研究试验中，我们研究一下使用寄存器的问题。

​	在汇编语言中，要使用寄存器，必须要给出寄存器名，在 C 语言中也是如此。

​	tc2.0 提供的编译器支持如下寄存器名：
```assembly
“_AX”, “_BX”, “_CX”, “_DX”, “_SI”, “_DI”, “_SP”, 
“_BP”, “_CS”, “_DS”, “_SS”, “_ES”, “_AL”, “_AH”, 
“_BL”, “_BH”, “_CL”, “_CH”, “_DL”, “_DH”。
```

从这些寄存器名称，可以看出它们对应的是哪个寄存器。

用 c:\minic 目录下的 tc.exe 完成以下试验：

(1) 编一个程序 url.c。

```c
main()
{
	_AX=1;
	_BX=1;
	_CX=2;
	_AX=_BX+_CX;
	_AH=_BL+_CL;
	_AL=_BH+_CH;
}
```

把这段程序保存在 c:\\minic 下，然后，编译，连接，生成 url.exe。

(2) 用 Debug 加载 url.exe，用 u 命令查看 url.c 编译后的机器码和汇编代码。

​	思考：main 函数的代码在什么段中？用 Debug 怎样找到 url.exe 中 main 函数的代码？

​	答：main 函数为可执行代码，必然在代码段中，所以通过 U 指令，就可以找到 main 函数代码，其偏移地址为 01FA

(3) 用下面的方法打印出 url.exe 被加载运行时，main 函数在代码段中的偏移地址：

```c
main()
{
	printf("%x\n",main);
}
```

​	“%x”指的是按照十六进制格式打印。

​	思考：为什么这个程序能够打印出 main 函数在代码段中的偏移地址？

​	答：main 是一个标号，他在程序中是以**偏移地址** 1fah 的形式存在，最终传递给 printf 打印出来。

(4) 用 Debug 加载 url.exe，根据上面打印出的 main 函数的偏移地址，用 u 命令察看 main 函数的汇编代码。仔细找到 url.c 中每条 C 语句对应的汇编代码。

​	注意：在这里，对于 main 函数汇编代码开始处的 \"push bp mov bp,sp\" 和结尾处的 \"pop bp\"，这里只理解到：这是 C 编译器安排的为函数中可能使用到 bp 寄存器而设置的，就可以了。

(5) 通过 main 函数后面有 ret 指令，我们可以设想：C 语言将函数实现为汇编语言中的子程序。研究下面程序的汇编代码，验证我们的设想。

程序 ur2.c:

```c
void f(void);
main()
{
	_AX=1; _BX=1; _CX=2;
	f();
}
void f(void)
{
	_AX=_BX+_CX;
}
```

答：调用子程序(call)就相当于 C 语言中的调用子函数，子程序返回(ret)就相当于 C 语言中的子函数返回，二者对应关系很明显。

### 研究试验 3 使用内存空间

​	寄存器只有十几个，但是内存空间可以很大。那么在 C 语言里如何使用内存空间呢？其实，寄存器也好，内存空间也好，都是存储空间，对于存储空间来说，要使用它们一般都需要给出两个信息：①指明是存储空间所在、是哪个的信息；②指明存储空间有多大类型信息。

​	对于寄存器来说，就需要给出发存器的名称，寄存器的名称中也包含了它们的类型信息。

​	对于内存空间来说，就只需要给出地址(准确地说，是内存空间首地址)和空间存储数据的类型。

​	我们知道，在 C 语言里，用指针型数据来表示内存空间的地址和空间存储数据的类型。比如要向偏移地址为 2000h，存储一个字节的内容空间写入一个字符'a'，我们用如下的方法：

```assembly
(char *)0x2000='a';
```

​	第一个“*”表示访问的是个内存空间;

​	“0x2000”是一个数值(0x 表示十六进制)，“(char *)"里面的“\*”指明了这个数值表示一个内存空间的地址，“char”指明了这个地址是存储 char 型数据的内存空间的地址。

​	当然也可以用指出段地址和偏移地址的方法访问内存空间，比如我们要向地址为 2000:0、存储一个字节的内存空间写入字符'a'，如下：

```assembly
(char far *)0x20000000='a';
```

​	“far" 指明内存空间的地址是段地址和偏移地址，“0x20000000”中的“0x2000”给出了段地址，“0000”给出了偏移地址。

​	不过这样直接用地址访问内存空间的方式是不安全的，因为，如果这些空间并不是分配给我们的程序使用的空间，这样做就可能改变了别的程序的代码或数据，引起错误。

​	我们可以按照上面的例子，举一反三，以前学过的 C 语言相关知识进行深入的理解。

​	用 c:\minic 目录下的 tc.exe，完成下面的试验。

(1) 编一个程序 uml.c:

```assembly
main(){
	* (char *)0x2000='a';
	* (int *)0x2000=0xf;
	* (char far *)0x20001000='a';
	
	_AX=0x2000;
	* (char *)_AX='b';
	
	_BX=0x1000;
	*(char *)(_BX+_BX)='a';
	*(char far *)(0x20001000+_BX)=*(char *)_AX;
}
```

​	把 uml.c 保存在 c:\minic 下，编译，连接生成 um1.exe。然后用 Debug 加载 um1.exe，对 main 函数的汇编代码进行分析，找到每条 C 语句对应的汇编代码；对 main 函数进行单步跟踪，察看相关内存单元的内容。

(2) 编一个程序，用一条 C 语句实现屏幕中间显示一个绿色的字符“a”。

​	答：`(int far *)0xb80007d0=0x0261;`

(3) 分析下面程序中所有函数的汇编代码，思考相关问题。

```c
int al,a2,a3;
void f(void);
main()
{
	int bl,b2,b3;
	al=0xal;a2=0xa2;a3=0xa3;
	bl=0xb1;b2=0xb2;b3=0xb3;
}
void f(void)
{
	int cl,c2,c3;
	al=0xfal;a2=0xfa2;a3=0xfa3;
	cl=0xc1;c2=0xc2;c3=0xc3;
}
```

​	问题：C 语言将全局变量存放在哪里？将局部变量存放在哪里？每个函数开头的 “push bp mov bp,sp” 有何含义？

​	答：const 修饰的全局变量放在**文字常量区**，未初始化的全局变量放在 **BSS 段**，普通全局变量放在**静态区/全局区**，三者都属于**静态存储区**。局部变量放在**栈区**，属于**动态存储区**。

​	函数开头的两条指令实现了子函数栈帧的初始化，确保函数执行期间栈空间管理的独立性，且不会干扰主调函数的栈的管理。

(4) 分析下面程序的汇编代码，思考相关问题。

```assembly
int f(void);
int a,b,ab;
main()
{
	int c;
	c=f();
}

int f(void)
{
	ab=a+b;
	
	return ab;
}
```

​	问题：C 语言将函数的返回值存放在哪里？

​	答：call 指令后面有`mov [bp+idata],ax`（idata 可以是正数、负数或者零），说明函数的返回值是先用 ax 寄存器暂存，然后存回栈中的。

(5) 下面的程序向安全的内存空间写入从“a”到“h”的 8 个字符，理解程序的含义，深入理解相关的知识。(注意：请自己学习、研究 malloc 函数的用法)

```c
#define Buffer ((char *)*(int far *)0x200)
main()
{
	Buffer=(char *)malloc(20);
	Buffer[10]=0;
	while(Buffer[10]!=8)
	{
		Buffer[Buffer[10]]='a'+Buffer[10];
		Buffer[10]++;
	}
	free(Buffer);
}
```

### 研究试验 4 不用 main 函数编程

​	在本研究试验中，我们看看如何不用 main 函数，编写可以正确运行的程序。我们用一个简单的程序来进行研究。

​	程序 f.c:

```c
f()
{
	*(char far *) (0xb8000000+160*10+80)='a';
	*(char far *) (0xb8000000+160*10+81)=2;
}
```

​	下面，我们研究如何用 tc.exe 对 f.c 进行编译，连接，生成可正确运行的 f.exe。

​	我们用 c:\minic 下的 tc.exe 完成以下试验。

(1) 把程序 f.c 保存到 c:\minic 下，对其进行编译，连接。思考相关的问题。

问题：

​	①编译和连接哪个环节会出问题？

​	②显示出的错误信息是什么？

​	③这个错误信息可能与哪个文件相关？

答：

​	①编译会成功而连接会出错

​	②错误信息：undefined symbol '_main' in module C0S

​	③错误信息和 c0s 文件夹有关，删除 c0s 文件夹后，错误信息会变成 linker error: Unable to open input file 'C0S.OBJ'，可以说明 link 和 c0s 文件夹有关，而且 main 函数定义在 C0S 文件中。

(2) 用学习汇编语言时使用的 link.exe 对 tc.exe 生成的 f.obj 文件进行连接，生成 f.exe。用 Debug 加载 f.exe，察看整个程序的汇编代码。思考相关的问题。

问题：

​	① f.exe 的程序代码总共有多少字节？

​	② f.exe 的程序能正确返回吗？

​	③ f 函数的偏移地址是多少？

答：

​	①实际代码长度 29 字节，连接后整个程序占 541 字节。push bp、mov bp,sp、pop bp 共占 1+2+1=4 字节，函数体占 25 字节。

​	②无法正确返回，debug 模式下 U 命令查看可以发现没有 mov ax,4c00h、int 21。

​	③偏移地址：00H

(3) 写一个程序 m.c。

```c
main()
{
	*(char far *)0xb8000000+160*10+80)='a';
	*(char far *)0xb8000000+160*10+81)=2;
}
```

​	用 tc.exe 对 m.c 进行编译，连接，生成 m.exe。用 Debug 察看 m.exe 整个程序的汇编代码。思考相关的问题。

问题：

​	① m.exe 的程序代码总共有多少字节？

​	② m.exe 能正确返回吗？

​	③ m.exe 程序中的 main 函数和 f.exe 中的 f 函数的汇编代码有何不同？

答：

​	① 25 字节，恰好比之前的 f() 函数少了 push bp、mov bp,sp、pop bp 共占 1+2+1=4 字节指令。

​	② 可以正确返回，主函数调用后有 mov ax,4c00h、int 21。

​	③ 除了标号名称不同外，f() 函数比 main() 函数多了一条 ret 指令。

(4) 用 Debug 对 m.exe 进行跟踪：①找到对 main 函数进行调用的指令的地址；②找到整个程序返回的指令。注意：使用 g 命令和 p 命令。

答：

​	① 找 call 01FA 的指令的地址即可，偏移地址为 011AH

​	② 找  mov ax,4c00h、int 21 两条指令位置即可(注意，实际上是 mov ah,4c、mov al,[BP+2] 两条指令构成的 mov ax,4c00h，不要看漏了)，偏移地址 0156H。

(5) 思考如下几个问题：

​	①对 main 函数调用的指令和程序返回的指令是哪里来的？

​	②没有 main 函数时，出现的错误信息里有和“cos”相关的信息；而前面在搭建开发环境时，没有 cos.obj 文件 tc.exe 就无法对程序进行连接。是不是 tc.exe 把 cos.obj 和用户程序的.obj 文件一起进行连接生成.exe 文件？

​	③对用户程序的 main 函数进行调用的指令和程序返回的指令是否就来自 cos.obj 文件？

​	④我们如何看到 cos.obj 文件中的程序代码呢？

​	⑤cos.obj 文件里有没有我们设想的代码吗？

答：

​	①来自于 c0s.obj 文件

​	②是

​	③对的，之前去掉该文件后会发现无法成功连接。

​	④对目录下的 c0s.obj 编译成 .exe 文件，然后 debug 模式下用 u 命令查看。

​	⑤有

(6) 用 link.exe 对 c:\minic 目录下的 c0s.obj 进行连接，生成 c0s.exe。

​	用 Debug 分别察看 c0s.exe 和 m.exe 的汇编代码。注意：从头开始察看，两个文件中的程序代码有何相同之处？

答：

​	二者头尾部分二进制代码相似度很高。

(7) 用 Debug 找到 m.exe 中调用 main 函数的 call 指令的偏移地址，从这个偏移地址开始向后察看 10 条指令；然后用 Debug 加载 c0s.exe，从相同的偏移地址开始向后察看 10 条指令。对两处的指令进行对比。

答：

​	二者形式很相近，只是调用 call 命令后面的偏移地址不同。

(8) 从上我们可以看出，tc.exe 把 c0s.obj 和用户.obj 文件一同进行连接，生成.exe 文件。按照这个方法生成的.exe 文件中的程序的运行过程如下。

​	① c0s.obj 里的程序先执行，进行相关的初始化，比如，申请资源、设置 DS、SS 等寄存器；

​	② c0s.obj 里的程序调用 main 函数，从此用户程序开始运行；

​	③ 用户程序从 main 函数返回到 c0s.obj 的程序中；

​	④ c0s.obj 的程序接着运行，进行相关的资源释放，环境恢复等工作；

​	⑤ c0s.obj 的程序调用 DOS 的 int 21h 例程的 4ch 号功能，程序返回。

​	看来，C 程序必须从 main 函数开始，是 C 语言的规定，这个规定不是在编译时保证的（tc.exe 对 f.c 的编译是可以通过的，也不是连接的时候保证的(虽然，tc.exe 文件对 f.obj 文件不能连接成 f.exe，但 link.exe 却可以），而是用如下的机制保证的。

​	首先，C 开发系统提供了用户写的应用程序正确运行所必须的初始化和程序返回等相关程序，这些程序存放在相关的.obj 文件（比如，c0s.obj）中。

​	其次，需要将这些文件和用户.obj 文件一起进行连接，才能生成可正确运行的.exe 文件。

​	第三，连接在用户.obj 文件前面的由 C 语言开发系统提供的 .obj 文件里的程序要对 main 函数进行调用。

​	基于这种机制，我们只要改写 c0s.obj，让它调用其他函数，编程时就可以不写 main 函数了。

​	下面，我们用汇编语言编一个程序 c0s.asm，然后把它编译为 c0s.obj，替代 c:\minic 目录下的 c0s.obj。

程序 c0s.asm：

```assembly
assume cs:code
data segment
	db 128 dup (0)
data ends  
code segment  
start: 
	mov ax,data  
	mov ds,ax  
	mov ss,ax  
	mov sp,128
	
	call s
	
	mov ax,4c00h  
	int 21h  
s:

code ends

end start  
```

​	用 masm.exe 对 c0s.asm 进行编译，生成 c0s.obj，把这个 c0s.obj 复制到 c:\minic 目录下覆盖由 tc2.0 提供的 c0s.obj。  

(9) 在 c:\minic 目录下，用 t.exe 将 f.c 重新进行编译，连接，生成 f.exe。这次能通过连接吗？f.exe 可以正确运行吗？用 Debug 察看 f.exe 的汇编代码。  

​	答：能连接，也可以正确运行。

(10) 在新的 c0s.obj 的基础上，写一个新的 f.c，向安全的内存空间写入从“a”到“h”的 8 个字符。分析、理解 f.c。

程序 f.c:

```c
#define Buffer ((char * )*(int far *)0x200)
f()
{
	Buffer=0;
	
	Buffer[10]=0;
	
	while(Buffer[10]!=8)
	{
		Buffer[Buffer[10]]='a'+Buffer[10];
	
		Buffer[10]++;
	}
}
```

​	注意，完成上面的相关试验后，把 c:\minic 目录下的 c0s.obj 文件恢复为 tc2.0 提供的 c0s.obj 文件。

### 研究试验 5 函数如何接收不定数量的参数

用 c:\minic 下的 tc.exe 完成下面的试验。

(1) 写一个程序 a.c:

```c
void showchar(char a,int b);

main()
{
	showchar('a',2);
}

void showchar(char a,int b)
{
	*(char far *)(0xb8000000+160*10+80)=a;
	*(char far *)(0xb8000000+160*10+81)=b;
}
```

​	用 tc.exe 对 ac 进行编译，连接，生成 a.exe。用 Debug 加载 a.exe，对函数的汇编代码进行分析。解答这两个问题： main 函数是如何给 showchar 传递参数的？showchar 是如何接收参数的？

答：

​	① main 将参数压入栈中传给 showchar，showchar 按通过 [bp+idata] 从栈中取参数。

​	② 注意函数传入参数入栈顺序是从**右到左**。

​	③ 注意栈中除了与 showchar 字符偏移相关的参数，还有调用子程序，会将 bp 压入栈，调用 call 会将 IP 压入栈，注意正确描述 bp 指针的位置，才能把参数正确传递给 showchar。

(2) 写一个程序 b.c:

```c
void showchar(int,int,...);

main()
{
	showchar(8,2,'a','b','c','d','e','f','g','h');
}

void showchar(int n,int color,...)
{
	int a;
	
	for(a=0;a!=n;a++)
	{
        *(char far *)(0xb8000000+160*10+80+a+a)=*(int *)(_BP+8+a+a);
        *(char far *)(0xb8000000+160*10+81+a+a)=color;
	}
}
```

​	分析程序 b.c，深入理解相关的知识。

​	思考：showchar 函数是如何知道要显示多少个字符的？ printf 函数是如何知道有多少个参数的？

答：

​	①传递给 showchar() 的第一个参数就是循环次数，决定了显示多少个字符。

​	② printf 函数通过`cmp al,25`+ je 比较条件跳转指令，比较“%”个数来判断参数个数并处理。

(3) 实现一个简单的 printf 函数，只需要支持 “%c、%d” 即可。

分析：

​	① 根据 cmp al,'%' 判断参数个数

​	② 字符型直接送至显存空间显示

​	③ 整形需要用之前提到的整数分解转换为字符串的技巧化成字符型，然后再进行步骤②
